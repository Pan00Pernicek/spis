#!/bin/bash

# load buffermaker framework library
source buffermaker

ebashs_version='0.9'

## Ebashs
#		Emacs-like editor written in pure Bash
#		Had been tested properly only on Bash 5.2, and will propably be broken on 4.x versions and definitelly on 3 and older.

function load-default-config-ebashs {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options → define-options() → ass. array options
	#				global-set → global-set-key → define-key global → as. ar. keys_global
	#				add-mode → local-set-key → define-key <keys> → a. a. keys_<keys>
	#					mode-options → local-set-mode-option → define-mode-option → a. a. key_options_<keys>
	#				set-alias → add-alias → a. a. alias
	#				add-menu → local-set-menu → define-menu <menu> → menu_<menu>_0 & menu_<menu>_1
	#				set-highlight → add-highlight → a. a. highlight
					  
	set-options
		:: mouse 0
		:: todonote 1
		:: menu-line 1
		:: mode-line 1
		:: command-line 1 # note that disabling this means that any message will instead be draw on top of buffer
		:: line-number-mode 1
		:: empty-line-char '~'
		:: tabchar '│   '
		:: file-prompt 'Path: '
		:: command-prompt 'M-x '
		:: cancelhex '18 0'
		:: default_mode 'edit'
		:: keep-message 0
		:: help-message "Ebashs $version"
		:: dired-message 'Pick a file'
		:: log 0
		:: log-functions 0
		:: tty-linuxfb 1 # enable truecolor support for framebuffer
		:: full-redraw 0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		:: welcome-buffer 1 # show welcome message instead of scratch
		:: esc-to-meta 1
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	global-set
		:: "$(kbd C-x)" 'prefix'
		:: "$(kbd M-x)" 'execute-extended-command'
		:: '[f10]' 'menu-top_menu'
		:: "$(kbd C-g)" 'quit-prefix'
		:: '[up]' 'previous-line'
		:: '[down]' 'next-line'
		:: '[right]' 'forward-char'
		:: '[left]' 'backward-char'
		:: '[next]' 'scroll-down'
		:: '[prior]' 'scroll-up'
		:: "$(kbd C-a)" 'move-beginning-of-line'
		:: "$(kbd C-e)" 'move-end-of-line'
		:: "$(kbd C-p)" 'previous-line'
		:: "$(kbd C-n)" 'next-line'
		:: "$(kbd C-f)" 'forward-char'
		:: "$(kbd M-f)" 'forward-word'
		:: "$(kbd C-b)" 'backward-char'
		:: "$(kbd M-b)" 'backward-word'
		:: "$(kbd M-v)" 'scroll-down'
		:: "$(kbd C-v)" 'scroll-up'

	add-mode edit
		:: '1b 5b 31 3b 32 41 0' select-previous
		:: '1b 5b 31 3b 32 42 0' select-next
		:: '1b 5b 31 3b 32 43 0' select-forward
		:: '1b 5b 31 3b 32 44 0' select-backward
		:: '1b 20 0' set-mark-command # in gnu emacs this is C-SPC but i cant get that to be detected in bash so M-SPC will suffice
		:: '20 0' insert-space
		:: "$(kbd C-h)" prefix-help
		:: 'RET' newline
		:: "$(kbd C-l)" newline
		:: "$(kbd M-d)" duplicate-line
		:: "$(kbd C-t)" execute
		:: "$(kbd C-d)" delete-line
		:: 'DEL' backspace
		:: '[deletechar]' delete
		:: "$(kbd M-g)" menu-key
		:: '1b 5b 48 0' move-beginning-of-line
		:: "$(kbd C-i)" indent-for-tab-command
		:: '1b 5b 46 0' move-end-of-line
		mode-options
			:: else 'insert'

	add-mode dired
		:: RET 'dired-select'
		:: "$(kbd h)" 'toggle_hidden'
	
	add-mode view
		:: RET 'quit-view'

	add-mode doc
		:: RET 'doc-select'
		:: "$(kbd C-c)" 'quit-doc'
	
	add-mode list_buffers
		:: RET 'buffer-select'
		mode-options
			:: else 'true'
	
	add-mode prefix
		:: "$(kbd C-c)" 'quit'
		:: "$(kbd C-s)" 'write_buffer'
		:: "$(kbd C-f)" 'find-file'
		:: "$(kbd C-b)" 'list-buffers'
		:: "$(kbd b)" 'switch-to-buffer'
		:: "$(kbd 0)" 'delete-buffer'
		:: "$(kbd u)" 'undo'
		mode-options
			:: always 'quit-prefix'
			:: disable-global 1
	
	add-mode prefix_help
		:: "$(kbd C-g)" 'quit-prefix'
		:: "$(kbd C-a)" 'about'
		:: "$(kbd r)" 'manual'
		:: "$(kbd f)" 'describe-function'
		:: "$(kbd C-f)" 'describe'
		mode-options
			:: disable-global 1

	add-mode menu
		:: '[up]' 'menuup'
		:: '[down]' 'menudown'
		:: 'RET' 'menuselect'
		mode-options
			:: else 'menuleave'
			:: disable-global 1

	add-mode format
		:: '[left]' format-left
		:: '[up]' format-up
		:: '[right]' format-right
		:: '[down]' format-down
		:: 'RET' link-enter
		:: "$(kbd C-c)" quit-view
		:: '[next]' 'scroll-down'
		:: '[prior]' 'scroll-up'
		:: "$(kbd C-a)" 'move-beginning-of-line'
		:: "$(kbd C-e)" 'move-end-of-line'
		:: "$(kbd C-p)" 'previous-line'
		:: "$(kbd C-n)" 'next-line'
		:: "$(kbd C-f)" 'forward-char'
		:: "$(kbd M-f)" 'forward-word'
		:: "$(kbd C-b)" 'backward-char'
		:: "$(kbd M-b)" 'backward-word'
		:: "$(kbd M-v)" 'scroll-down'
		:: "$(kbd C-v)" 'scroll-up'
		:: "$(kbd C-x)" 'prefix'
		:: "$(kbd M-x)" 'execute-extended-command'
		:: '[f10]' 'menu-top_menu'
		:: "$(kbd C-g)" 'quit-prefix'
		mode-options
			:: else :
			:: disable-global 1

	add-mode welcome
		:: 'RET' link-enter
		:: "$(kbd f)" find-file
		:: "$(kbd b)" dired
		:: "$(kbd m)" manual
		:: "$(kbd d)" view-page
		:: "$(kbd a)" about
		:: "$(kbd i)" inputcodes
		:: "$(kbd c)" list-faces-display
		:: "$(kbd l)" view-log
		:: "$(kbd C-c)" quit-view
		mode-options
			:: else :
		
	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
edit_faces=(
		# syntax highlighting
		sh-quoted-exec "$(:foreground light-yellow)"
		font-lock-variable-string-face "$(:foreground cyan)"
		font-lock-comment-face "$(:weight dim)"
		font-lock-variable-name-face "$(:foreground light-cyan)"
		font-lock-argument-face "$(:foreground light-yellow)"
		font-lock-flow-face "$(:foreground ligth-yellow)"
		font-lock-pipe-face "$(:weight bold :foreground light-blue)"
		font-lock-bracket-face "$(:weight bold :foreground light-gray)"
		font-lock-constant-face "$(:foreground light-green)"
		font-lock-string-face "$(:foreground green)"
		font-lock-assign-face "$(:foreground light-blue)"
		font-lock-function-name-face "$(:weight bold :foreground light-cyan)"
		font-lock-keyword-face "$(:foreground light-red)"
		font-lock-util-face "$(:foreground light-magenta)"
		font-lock-declare-face "$(:foreground red)"
	)
	load-theme edit_faces

	## Aliases
	#		List of aliases for M-x.
	set-alias
		:: set-buffer-file 'find-file'
		:: read-file 'read-buffer'
		:: write-file 'write-buffer'
		:: force-quit 'die'
		:: menul 'menu-top_menu'
		:: menu-file 'menu-file'
		:: input 'inputcodes'
		:: log 'view-log'

	## Menus
	#		Defined via ordered pseudo-associative double-arrays
	#			All menu items calling 'menu-top' get applied the 'menu-back' face
	#
	#		Menu top is the top menuline & f10 menu	
	#		Menu dired is the top menuline in dired buffers	
	add-menu top
		:: File menu-file
		:: Keys menu-key
		:: Help menu-help
		:: Debug menu-debug
		:: Redraw refresh

	add-menu top_menu
		:: 'File   ' menu-file
		:: 'Keys   ' menu-key
		:: 'Help   ' menu-help
		:: 'Debug  ' menu-debug
		:: 'Redraw ' refresh

	add-menu file
		:: '        BACK        ' menu-top_menu
		:: 'Quit        C-x C-c ' quit
		:: 'Visit file  C-x C-f ' find-file
		:: 'Execute         C-t ' execute
		:: 'Save        C-x C-s ' write-buffer
		:: 'Dired               ' dired
	add-menu help
		:: '        BACK        ' menu-top
		:: 'Keybinding          ' menu-key
		:: 'About               ' about

	add-menu key
	    :: '        BACK        ' menu-top_menu
		:: 'Exit        C-x C-c ' quit
		:: 'New Line    C-l | ⏎ ' newline
		:: 'Visit file  C-x C-f ' find-file
		:: 'Save file   C-x C-s ' write-buffer
		:: 'Delete Line     C-d ' delete-line
		:: 'Prev Line       C-p ' previous-line
		:: 'Next Line       C-n ' next-line
		:: 'Prev Page       C-y ' scroll-down
		:: 'Next Page       C-v ' scroll-up
		:: 'Execute         C-t ' execute
		:: 'Shell           C-s ' shell
		:: 'Force exist     M-q ' die
    add-menu debug
		:: '   BACK   ' menu-top_menu
		:: 'clear     ' clear-screen
		:: 'refresh   ' refresh
		:: 'backspace ' backspace
		:: 'right     ' forward-char
		:: 'left      ' backward-char
		:: 'inputcodes' inputcodes
		:: 'faces     ' list-faces-display

	## Syntax highlighting
	set-highlight
		:: 'shell' bash ksh dash sh mksh zsh ash oksh i\*bash 'busybox sh'
		:: 'ebashs' ebashs
		:: 'config' conf
		:: 'execline' execlineb
		:: 'format-edit' format
		:: 'dired' i\*dired
		:: 'unknown' unknown

	add-menu dired
		:: 'toggle hidden (h)' "toggle_hidden"

	add-menu dialog
		:: quit 'quit-view'

	add-menu welcome
		:: about 'about'
		:: manual 'manual'
		:: docs 'view-page'
		:: quit 'quit-view'
	
	# Navigation used in some inbuild buffers
	#format_nav="<a> about : <f> link About </f> </a> "
	#format_nav+="<a> manual : <f> link Manual </f> </a> "
	#format_nav+="<a> view-page : <f> link Documentation </f> </a>"
	format_nav="<o> id: about select: about right: obj manual text: <f> link About </f> </o> "
	format_nav+="<o> id: manual select: manual left: obj about right: obj doc text: <f> link Manual </f> </o> "
	format_nav+="<o> id: doc select: view-page left: obj manual right: next-line text: <f> link Documentation </f> </o>"
}

## Documentation
function load-doc {
	mapfile -t -O 1 top_doc <<'EOF'
<h> Documentation </h>

<tab> <link> goto doc_control : Controls </link>
<tab> <link> describe : Functions </link>
<tab> <link> goto doc_faces : Face setting </link>
EOF

	mapfile -t -O 1 doc_control <<'EOF'
<link> goto top_doc : Back </link>
<h> [ Controls ] </h>

Automatically generated list of keybindings. Click on function name to view it's documentation.
Note that currently only key set via $(kbd C-char or M-char) will show up.
EOF
	for mode in "${modes[@]}"; do
		doc_control+=(
			'</i>'
			"<h> ${mode} </h>"
			'<i-tab>'
		)
		local -n moderef="$mode"
		for ch in\
			C-a C-b C-c C-d C-e C-f C-g C-h C-i C-j C-k C-l C-m C-n C-o C-p C-q C-r C-s C-t C-u C-v C-w C-x C-y C-z :\
			M-a M-b M-c M-d M-e M-f M-g M-h M-i M-j M-k M-l M-m M-n M-o M-p M-q M-r M-s M-t M-u M-v M-w M-x M-y M-z	
		do
			[ "$ch" = ':' ] && {
				doc_control+=('')
				continue
			}
			key=${moderef[$(kbd ${ch})]}
			[ -z "$key" ] && continue
			doc_control+=(
				"<f> highlight ${ch} </f> <a> doc-select $key : <f> font-lock-function-name-face $key </f> </a>"
			)
		done
	done
	doc_control+=(
		'</i>'
	)

	mapfile -t -O 1 doc_faces <<'EOF'
<link> goto top_doc : Back </link>
<h> [ Face configuration ] </h>

Faces are set via theme arrays. Theme array consists pairs of name and value.
The first is name, second is value, then again first... second... ... ... . The
Theme array has to be then loaded via <link> doc-select load-theme : load-theme </link> function.

Faces configured via escape codes, for example:
<-> <f> blue perfectblue '\e[44m' </f>
Produces blue colored face

But <[> title Ebashs is civilised and so has nicer settings for this:
<-> <f> blue perfecterblue "$(:background blue)" </f>
or one of 256 colors:
<-> <f> blue blue256 "$(:background c18)" </f>
or if you use nice terminal even full 24 bit hex. color:
<-> <f> blue TRUEBLUE "$(:background " <-f> ansi-color-blue #0000ff </f-> ")" </f>

The face-setting functions can be combined:
<-> <f> red red <-f> cyan cyan </f> </f> <f> cyan "$(:background <f> ansi-color-cyan c44 </f> </f> <f> red :foreground <f> ansi-color-red c196 </f-> )" </f>

<-> <-> see <link> doc-select :foreground : :foreground </link> <link> doc-select :background : :background </link> <link> doc-select setface : setface </link>

The boldness and dimness can be set via <a> doc-select :weight : <f> link :weight </f> </a> function.
The inverseness can be set via <a> doc-select :mode : <f> link :mode </f> </a> function.
The slant can be set via <a> doc-select :slant : <f> link :slant </f> </a> function.

<h> Example </h>

To change faces used on this page

<-> <f> title misleading_theme </f-> =( <i> 8
<[> title title "$(:weight bold :background "#ffffff")"
<[> link link "$(:weight bold :background light-yellow)"
<[> ansi-color-blue ansi-color-blue "$(:background cyan)"
<[> ansi-color-cyan ansi-color-cyan "$(:background green)"
<[> blue blue "$(:foreground cyan)"
<[> red red "$(:foreground yellow)"
<[> font-lock-keyword-face font-lock-keyword-face ''
<[> cyan cyan "$(:foreground green)" </i>
<-> )
<-> <f> font-lock-keyword-face load-theme </f> <f> title misleading-theme </f>
EOF
}

@@ execute-extended-command
:: 'Handles M-x command prompt & execution'
function execute-extended-command {
	read-command "${options[command-prompt]}" readin || return 1
	for lcmd in "${!alias[@]}"; {
		[ "$readin" = "$lcmd" ] && {
			${alias[$lcmd]}
			return
		}
	}
	$readin			
	((noredraw)) && noredraw=0 || redraw
}

@@ save Saves current buffer references data as '$1'
function save {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	savedcurrent_buffer="$current_buffer"
}

@@ restore Restores '$1' buffer references data to current
function restore {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	set-buffer "${savedcurrent_buffer}"
}

@@ set-syntax
:: Picks syntax highlighting function for current filetype
function set-syntax
	if [ -n "${highlight[*]}" ] && bf_d[syntax]="syntax-${highlight[unknown]}"
	then
		for syntax_setting in "${!highlight[@]}"; {
			[ "$syntax_setting" = "${bf_d[filetype]}" ] && {
				bf_d[syntax]="syntax-${highlight[$syntax_setting]}"
			}
		}
	else
		log warn 'no highlight array... using unknown'
	fi

@@ syntax-shell
:: Syntax function for shell
:: Used faces:
	:+ '* sh-quoted-exec'
	:: '* font-lock-declare-face'
	:: '* font-lock-variable-string-face'
	:: '* font-lock-comment-face & sets comment to 1 for syntax-word function'
	:: '* font-lock-variable-name-face'
	:: '* font-lock-argument-face'
	:: '* font-lock-function-name-face'
	:: '* font-lock-flow-face'
	:: '* font-lock-pipe-face'
	:: '* font-lock-bracket-face'
	:: '* font-lock-constant-face'
	:: '* font-lock-string-face'
	:: '* font-lock-assign-face'
	:: '* font-lock-keyword-face'
	:: '* font-lock-default-face'
function syntax-shell
	case "${word}" in
		'$('*|'"$('*) set-face sh-quoted-exec;;
		*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*) set-face font-lock-variable-name-face;;
		'-'*) set-face font-lock-argument-face;;
		*'()') set-face font-lock-function-name-face;;
		'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
		'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
		'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
		'function') set-face font-lock-function-name-face;;
		*"'"*) set-face font-lock-constant-face;;
		*'"'*) set-face font-lock-string-face;;
		*'='*) set-face font-lock-assign-face;;
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
		'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
		'let'|'shopt'|'trap'|'set'|'eval'\
			) set-face font-lock-keyword-face;;
		*) set-face default;;
	esac

@@ syntax-ebashs
:: Syntax function for shell
:: Used faces:
	:+ '* sh-quoted-exec'
	:: '* font-lock-declare-face'
	:: '* font-lock-variable-string-face'
	:: '* font-lock-comment-face & sets comment to 1 for syntax-word function'
	:: '* font-lock-variable-name-face'
	:: '* font-lock-argument-face'
	:: '* font-lock-function-name-face'
	:: '* font-lock-flow-face'
	:: '* font-lock-pipe-face'
	:: '* font-lock-bracket-face'
	:: '* font-lock-constant-face'
	:: '* font-lock-string-face'
	:: '* font-lock-assign-face'
	:: '* font-lock-keyword-face'
	:: '* font-lock-default-face'
function syntax-ebashs
	case "${word}" in
		'$('*|'"$('*) set-face sh-quoted-exec;;
		*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*|'@') set-face font-lock-variable-name-face;;
		'-'*|'::') set-face font-lock-argument-face;;
		*'()') set-face font-lock-function-name-face;;
		'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
		'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
		'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
		'new'|'template'|'@def'|'@fn'|'@:') set-face font-lock-function-name-face;;
		*"'"*) set-face font-lock-constant-face;;
		*'"'*) set-face font-lock-string-face;;
		*'='*|'function') set-face font-lock-assign-face;;
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
		'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
		'let'|'shopt'|'trap'|'set'|'eval'\
			) set-face font-lock-keyword-face;;
		'set-options'|'global-set'|'define-key'|'local-set-key'|'add-mode'|'mode-options'|\
		'load-theme'|'set-alias'|'add-menu'|'@ifs'|'doc'|'_'|'__'|'copy-array'|\
		':foreground'|':background'|':mode'|'weight'|':slant'|'kbd'|'add-highlight'\
			) set-face font-lock-keyword-face;;
		*) set-face default;;
	esac

@@ syntax-execline
:: Syntax function for execline
function syntax-execline
	case "${word}" in
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*) set-face font-lock-variable-name-face;;
		'-'*) set-face font-lock-argument-face;;
		'{'|'}') set-face font-lock-bracket-face;;
		*'"'*) set-face font-lock-string-face;;
		'execlineb'|'execline-cd'|'posix-cd'|'cd'|'execline-umask'|'posix-umask'|'umask'|\
		'emptyenv'|'envfile'|'export'|'unexport'|'fdclose'|'fdblock'|'fdmove'|'fdswap'|'fdreserve'|\
		'redirfd'|'piperw'|'heredoc'|'wait'|'getcwd'|'getpid'|'exec'|'tryexec'|'exit'|'trap'|'withstdinas'|\
		'foreground'|'background'|'case'|'if'|'ifelse'|'ifte'|'ifthenelse'|'backtick'|'pipeline'|'runblock'|\
		'define'|'importas'|'elglob'|'elgetpositionals'|'multidefine'|'multisubstitute'|\
		'fox'|'forstdin'|'forbacktickx'|'loopwhilex'|\
		'elgetopt'|'shift'|'dollarat'|\
		'eltest'|'homeof'|\
		'execline') set-face font-lock-keyword-face;;
		's6-basename'|'s6-cat'|'s6-chmod'|'s6-chown'|'s6-clock'|'s6-cut'|'s6-dirname'|'s6-dumpenv'|\
		's6-echo'|'s6-env'|'s6-expr'|'s6-false'|'s6-format-filter'|'s6-grep'|'s6-head'|'s6-hiercopy'|\
		's6-linkname'|'s6-ln'|'s6-ls'|'s6-maximumtime'|'s6-mkdir'|'s6-mkfifo'|'s6-nice'|'s6-nuke'|\
		's6-pause'|'s6-printenv'|'s6-quote-filter'|'s6-quote'|'s6-rename'|'s6-rmrf'|'s6-seq'|\
		's6-sleep'|'s6-sort'|'s6-sync'|'s6-tai64ndiff'|'s6-tail'|'s6-touch'|'s6-true'|'s6-uniquename'|\
		's6-unquote-filter'|'s6-unquote'|'s6-update-symlinks'|'seekablepipe'|\
		's6-portable-utils') set-face font-lock-util-face;;
		'rngseed'|'s6-chroot'|'s6-freeramdisk'|'s6-hostname'|'s6-logwatch'|'s6-mount'|\
		's6-pivotchroot'|'s6-ps'|'s6-swapoff'|'s6-swapon'|'s6-umount') set-face font-lock-util-face;;
		*) set-face default;;
	esac

@@ syntax-format-edit
:: Syntax function for ebashs\'s formatter
function syntax-format-edit
	case "${word}" in
		'<f>'|'<-f>'|'</f>'|'</f->'|'<u>'|'</u>'|'<tab>'|'<i>'|'</i>'|'<i-tab>'|'<h>'|'<s>'\
			)set-face font-lock-keyword-face;;
		*) set-face default;;
	esac
@@ syntax-unknown Default syntax function
:: Sets everything to default face
@fn syntax-unknown 'set-face default'

@@ syntax-list-buffers
:: Syntax function for list-buffers
function syntax-list-buffers {
	((syntaxline==2)) && {
		face hint "$word"
		return
	}
	local -n cbf_d="${word}_bf_d"
	face link "$(printf '%*s' -6 "$word")"
	face file-name "$(printf '%*s' -16 "${cbf_d[file]}")"
	face default "$(printf '%*s' -10 "${cbf_d[mode]}")"
	face font-lock-comment-face "${cbf_d[modified]} "
}

@@ syntax-dired
:: Highlighting for dired buffers
:+     '* Directories → link'
::     '* Files → default'
function syntax-dired {
	[ -d "$word" ] && set-face link
	[ -f "$word" ] && set-face default
}

@@ syntax-config
:: Basic syntax function for config files
:: Used faces:
:+     '* default'
::     '* font-lock-comment-face & sets comment to 1 for syntax-word function'	
function syntax-config
	case "${word}" in
		'#'*) set-face font-lock-comment-face && comment=1;;
		*) set-face default;;
	esac

@@ base-name
:: Basically equivalent to the "'basename'" coreutil		
function base-name
	for file in "$@"; {
		file="${file%/}"
		printf '%s\n' "${file##*/}"
	}

@@ filetype
:: Detect type of file '$1':					
:+     "* If file doesn't exist → unknown"
::     "* If is COMMIT_EDITMSG → conf"
::     "* If is ebashs → ebashs"
::     "* Extension →"
::     "* Shebang →"
::     "* Special shebang #@ →"
::     "* unknown →"
function filetype {
	[ ! -f "$1" ] && {
		echo unknown
		return
	}
	#very ugly, TODO: redo this
	local filename shebang extension
	local -a filenamesplit shebangsplit
	[ $# = 0 ] && return
	[ "${1:0:1}" = '.' ] || {
		IFS='.'
		filename="${1%/}"
		filename="${filename##*/}"
		[ "$filename" = 'COMMIT_EDITMSG' ] && echo conf && return
		[ "$filename" = 'ebashs' ] && echo ebashs && return
		filenamesplit=($filename)
		extension="${filenamesplit[-1]}"
		[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && return
	}
	mapfile -n 1 file_data < "$1"
	shebang="$(echo -n "${file_data[@]}")"
	case "${shebang:0:2}" in
		'#!')
			shebang="${shebang%/}"
			IFS=' '
			shebangsplit=("${shebang##*/}")
			local shebangss=(${shebangsplit[-1]})
			case "${shebangss[0]}" in
				env)
					printf '%s\n' "${shebangss[1]}";;
				*)
					printf '%s\n' "${shebangsplit[-1]}";;
			esac
			;;
		'! ')
			mapfile -d ' ' -t split <<< "${shebang}"
			printf '%s\n' "${split[1]}"
			;;
		'##')
			mapfile -d ' ' -t split <<< "${shebang}"
			printf '%s\n' "${split[1]}"
			;;
		*) echo unknown
	esac
	@ifs
}

@@ find-file
:: Asks for file and opens it
function find-file {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	bind 'set disable-completion off' 2>/dev/null # Enable completion
	read -re -p "${options[file-prompt]}" command && {
		read-buffer "$command"
		[ -n "$bckmode" ] && bf_d[mode]="$bckmode" || bf_d[mode]=edit
		redraw
	}
	bind 'set disable-completion on' 2>/dev/null
}

@@ view-format
:: Open file as formated document
function view-format {
	save openfile
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	bind 'set disable-completion off' 2>/dev/null # Enable completion
	read -re -p "${options[file-prompt]}" command && {
		read-buffer "$command"
		bf_d[syntax]=syntax-format
		bf_d[syntax-exec]=1
		[ -n "$bckmode" ] && bf_d[mode]="$bckmode" || bf_d[mode]=view
		redraw
	}
	bind 'set disable-completion on' 2>/dev/null
}

@@ insert-debug-hex
:: Adds hex code of keypress into buffer
function insert-debug-hex {
	buffer+=(
		"${k_hex[*]}"
	)
	next-line
	make-render-line
	redraw
}

@@ switch-to-buffer
:: Interactive wrapper for set-buffer
function switch-to-buffer {
	redraw
	read-command "Switch to buffer: " readin
	set-buffer "$readin"
	redraw
}

@@ list-buffers
:: Displays currently active buffers
function list-buffers {
	save openfile
	set-buffer list_buffers
	declare -Ag "${current_buffer}_bf_d"
	focus set-buffer
		:: line 1
		:: base 1
		:: column 0
		:: modified 0
		:: mode 'list_buffers'
		:: info 'Currently open buffers'
		:: filetype 'i*buffer-list'
		:: file '*Buffer List*'
		:: syntax syntax-list-buffers
		:: syntax-exec 1
		:: menuline 'about'
	[auto]
	buffer=(
		''
		'ID    FILENAME        MODE      MODIFIED'
	)
	bf_s=('')
	append-array buffers_l buffer
	redraw
	}
	
@@ buffer-select
:: Is ran on RET inside list_buffers buffer
function buffer-select {
	((bf_d[line]==1)) && return
	set-buffer "${buffer[bf_d[line]]}"
	[ "${bf_d[mode]}" = 'prefix' ] && bf_d[mode]="$bckmode"
	redraw
}

add-mode debuginput
	local-set-key "$(kbd C-x)" 'quit-view'
	local-set-mode-option else 'insert-debug-hex'
	local-set-mode-option disable-global 1
add-menu debuginput
	local-set-key 'quit-debuginput'

@@ inputcodes
:: Opens debug input buffer
function inputcodes {
	save openfile
	declare-new-buffer
		:: mode 'debuginput'
		:: info 'C-x (18 0) to close'
		:: filetype 'i*term'
		:: file '*debuginput*'
		:: modified 0
		:: syntax syntax-unknown
		:: menuline 'debuginput'
		[auto]
		
	buffer=(
		''
		'[ KEY DEBUGGER ]'
		''
		"Press any key to see Ebashs's native hex. representation of it."
		"See C-h f define-key & C-h f kbd for fancier key settings"
		''
	)
	bf_d[line]=7
	redraw
}

@@ read-buffer
:: Reads file \$1 into new buffer
function read-buffer {
	log info "reading $* ..."
	declare-new-buffer
		:: mode "${options[default_mode]}"
		:: info "${options[help-message]}"
		:: filetype "$(filetype "$1")"
		:: file "$1"
		:: menuline 'top'
		:: current_state 0
	[auto]
	((options[view])) &&	
		[ "${bf_d[filetype]}" = 'format' ] && {
			:: mode format
			:: syntax syntax-format
			:: syntax-exec 1
		}
		
	[ -f "${bf_d[file]}" ] && mapfile -t -O 1 "${current_buffer}_buffer" <"${bf_d[file]}" # Read file into an array
	
	
	# Ensure that something was actually read into the file
	[[ -n "${buffer[*]}" ]] && {
		message="Read ${#buffer[@]} lines from '${bf_d[file]}'"
	} || {
		message="'${bf_d[file]}' is empty"
	}
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ toggle_hidden
:: Toggles hidden files in dired buffer
function toggle_hidden {
	((hidden==0)) && hidden=1 || hidden=0
	dired
}

@@ dired
:: Open file manager in current working directory
function dired {
	declare-new-buffer
		:: info 'Dired'
		:: mode 'dired'
		:: filetype 'i*dired'
		:: file '*dired*'
		:: menuline 'dired'
		[auto]
		
	mapfile -t -O 1 buffer <<< "$(list-directory)"
	make-render
	if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
		bf_d+=(
			[line]=1
			[info]="$PWD"
		)
	else
		bf_d[info]="error: empty"
	fi
	redraw
}

@@ dired-select
:: Select a item in dired buffer
	:+     '* If it is a directory cd into it and open new dired'
	::     '* If it is a file open it via read-buffer function'
function dired-select
	if [ -d "${buffer[bf_d[line]]}" ]; then
		cd "${buffer[bf_d[line]]}"
		dired
	else
		read-buffer "${buffer[bf_d[line]]}" || exit 1
		redraw
	fi

@@ init-log
:: Initializes M-x view-log buffer
function init-log {
	log=1
	declare -Ag "log_bf_d"
	declare -ng bufferlog="log_buffer"
	declare -ng bf_d="log_bf_d"
	focus set-buffer
		:: base 1
		:: column 0
		:: info 'LOG'
		:: mode 'view'
		:: help-message 'LOG'
		:: filetype 'i*view'
		:: file '*log*'
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
		:: menuline 'menulog'
	add-menu
		:: 'quit' 'quit-view'

	size-full

	bufferlog+=(
		''
		"<f> title Ebashs version $version </f>"
		"<tab> <f> highlight [ LOG START ] </f>"
		''
		'<f> title System info: </f> <i-tab>'
		"Bash version:  ${BASH_VERSION}"
		"System:        ${OSTYPE}"
		"Terminal type: ${TERM}"
		"Locale:        ${LANG} </i>" 
		''
		'<f> title Loaded extensions: </f>'
	)
	for e in "${extensions[@]}"; {
		local -n ext_d="${e}_ext_d"
		bufferlog+=("    $e - ${ext_d[version]}")
	}
	bufferlog+=(
		''
		'<f> hint level time function message </f>'
	)
	lasttime="$(current-time '%s')"
}

@@ view-log
:: Opens log buffer
function view-log {
	((log)) || {
		message='Error: log is not initialised'
		return
	}
	save openfile
	set-buffer log
	copy-array buffer bf_e
	clear-screen
	redraw
}

@@ buffer-dialog
:: Helper functions for creating simple popup buffers
function buffer-dialog {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "$1"
		:: mode view
		:: filetype 'i*view'
		:: file "$2"
		:: modified 0
		:: syntax syntax-unknown
	size-full
}

@@ buffer-dialog-draw
:: Draws buffer created by buffer-dialog
# NOTE: To be removed
function buffer-dialog-draw {
	clear-screen
	redraw
}
	
@@ about
:: Shows about information	
function about {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "About"
		:: mode format
		:: filetype 'i*format'
		:: file "*about*"
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	mapfile -t -O 1 buffer <<EOF
$format_nav

<h> Ebashs $ebashs_version </h>
Buffermaker $version

Copyright(č)ˇ 2022-2023 <f> title Netkv </f-> .
( <-f> title bed </f-> : Copyright(č)ˇ 2020 <f> title Comfies </f-> .)

This is Ebashs, one component of the Bash/Bash operating system.

An editor written in pure bash via nonsense sphagetti code trying copying emacs.

Repo <s> 19 <f> link https://github.com/aeknt/spis </f>
<s> 24 Ebashs comes with ABSOLUTELY NO WARRANTY




Based on <s> 15 <f> link https://github.com/comfies/bed </f>


<tab> <f> hint For more information about usage of Ebashs, press <f> light-gray C-h C-r </f> to view </f> <link> manual : manual </link>

<i> 5
<f> dr                          .............. </f>
<f> lr                       @***%@@@@@@@@@@@@... </f>
<f> dr                ** .*@@@@@@@@@@@@@@@@@@@@@.. </f>
<f> dy                .       @@&....,,#@@@@@@@@ </f>
<f> ly                 ....,@@@@@@@@@@@@@@@@@@ </f>
<f> dy             /@@@@@@@@@@@@@@@@@@@@@@. </f>
<f> dg           @@@@@@@,,...@@@&.. </f>
<f> lg         .@@@@@@@@@@@,,@@@&. </f>
<f> dg         ..@@@@@@@@@@@@@@@&.. </f>
<f> dc           .../@@@@@@@@@@@@@@..... </f>
<f> lc              ....@@@@@@@@@@@@@@@&.... </f>
<f> dc              ..(#@@@@@@@@@@@@@@@@@@@ </f>                                    
<f> db         ./@@@@@@@@@@@@@@@@%...... </f>
<f> lb     .@@@@@@@@@@@@@@@@.@@@&. </f>
<f> db   @@@@@@@@@@@@@@..   .@@@&. </f>
<f> dm  .@@@@@@@@@@@@.      .@@@&. </f>
<f> lm ..@@@@@@@@@@@@/.......@@@&. </f>
<f> dm  ...,@@@@@@@@@@@@@@@@@@@@&................. </f>
<f> gr      ...@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.. </f>
<f> dw          ....../@@@@@@@@@@@@@@@@@@@@@@@@@@@@@# </f>
<f> lw                   ..,,,,*##@@@@@@@@@@@@@@@.      .###################. </f>
<f> dw                 @@@@@@@@@@@@@@@@@@@@..        @@@@@@@@@@@@@@@@@@@@@@ </f>
<f> gr              /@@@@@@@/........              @@@@@@@@@@@@@@@@@@@@. </f>
</i>                                                                              
                                                                                

<i> 2 <f> hint ─[ <-f> light-cyan bsd0 </f-> ]───────────────────────────────────────────────────────────────────────────────────── </f->
Permission to use, copy, modify, and/or distribute this software for any purpose
with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<f> hint ──────────────────────────────────────────────────────────────────────────────────────────── </f> </i>

EOF
	redraw
}

@@ view-page
:: Display formated text nicely	
function view-page {
	save openfile
	declare-new-buffer
		:: line 3
		:: column 4
		:: info "view"
		:: mode format
		:: filetype 'format'
		:: file "*view*"
		:: modified 0
		:: isfile 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	clrmsg=0	
	message='loading...'
	redraw-commandline
	load-doc
	copy-array top_doc buffer
	redraw
}

@@ list-faces-display
:: Displays list of faces
function list-faces-display {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "$1"
		:: mode view
		:: filetype 'i*view'
		:: file '*format*'
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	buffer=('')
	for face in "${!faces[@]}"; do
		buffer+=(
			"$(printf '%*s' -40 "${face}") <f> ${face} abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ </f>"
		)
	done
	buffer-dialog-draw
}

@@ list-data-display
:: Displays list of data of buffer from bf_d array	
function list-data-display {
	read-command "List data of buffer: " readin
	local -n bdata="${readin}_bf_d"
	buffer-dialog faces 'data' '*list-data-display*'
	buffer=('')
	for datum in "${!bdata[@]}"; do
		buffer+=(
			"$(
			printf '%*s%s' -20 "${datum}" "${bdata[${datum}]}"
		)"
		)
	done
	buffer-dialog-draw
}

@@ list-options-display
:: Displays list of options
function list-options-display {
	buffer-dialog faces '*list-data-display*'
	buffer=('')
	for option in "${!options[@]}"; do
		buffer+=(
			"$(
				printf '%*s%s' -20 "${option}" "${options[${option}]}"
			)"	
		)
	done
	buffer-dialog-draw
}

@@ table-init
:: Initializes bml \(bash markup language\) table
function table-init {
	table_columns="$1"
	shift
	local -i i=0
	for col in "$@"; do
		local -n n="table_column_$i"
		n="$col"
		((i++))
	done
}

@@ table-char
:: Sets style of bml table
function table-char
	if (( ${#@} == 11 )); then
		table_char=("$@")
	else
		table_char=(─ │ ┌ ┬ ┐ ├ ┼ ┤ └ ┴ ┘)
	fi

@@ table-top
:: Prints top line of bml table
function table-top {
	printf '%s' "<f> hint ${table_char[2]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[3]}"
		((i==table_columns-1)) && printf '%s' "${table_char[4]}"
	done
	printf '%s\n' ' </f->'
}

@@ table-title-line
:: Prints bml table title divider
function table-title-line {
	printf '%s' "<f> hint ${table_char[5]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[6]}"
		((i==table_columns-1)) && printf '%s' "${table_char[7]}"
	done
	printf '%s\n' ' </f->'
}
@fn table-divider 'table-title-line "$@"'

@@ table-bottom
:: Prints bottom line of bml table
function table-bottom {
	printf '%s' "<f> hint ${table_char[8]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[9]}"
		((i==table_columns-1)) && printf '%s' "${table_char[10]}"
	done
	printf '%s\n' ' </f->'
}

@@ table-item
:: Prints line of table
function table-item {
	local -i i=0
	for item in "$@"; do
		local -n n="table_column_$i"
		printf '%s' "<f> hint ${table_char[1]} </f-> "
		printf '%s' "$item"
		printf '%*s' $(( n - ${#item} )) ''
		((i++))
	done
	printf '%s' "<f> hint ${table_char[1]}"
	printf '%s\n' ' </f->'
}

@@ table-title
:: Prints title of table
function table-title {
	local -i i=0
	for title in "$@"; do
		local -n n="table_column_$i"
		printf '<f> hint %s' "${table_char[1]} </f->"
		printf '%*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
		printf '%s' " <-f> title $title </f-> "
		if ((${#title}%2==0)) && ((n%2==1)); then
			printf ' %*s' $(( ( n / 2 - ( ${#title} / 2 ) ) + 1 )) ''
		else
			printf ' %*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
		fi
		((i++))
	done
	printf '%s' "<f> hint ${table_char[1]}"
	printf '%s\n' ' </f->'
}

@@ code-block
:: Prints code in bml document
function code-block while read -r; do echo " <-f> light-cyan $REPLY </f-> "; done

@@ print-stdin
:: Basically like coreutil "'cat'"
function print-stdin while read -r; do echo "$REPLY"; done

@@ text
:: Prints normal text in bml document
function text
	while read -r; do
		l=${#REPLY}
		for ((i=0; i<l; i+=(bf_d[size-x]/3)*2)); do
			printf '%s%s\n' "$1" "${REPLY:i:(bf_d[size-x]/3)*2}"
		done
	done

@fn title 'printf "[ <f> title %s </f> ]" "$@"'
@fn code 'printf "$@"'

@@ header
:: Prints header of bml document
function header {
	arg=$*
	table-init 1 $(( ${#arg} * 2 ))
	table-char ═ ║ ╔ X ╗ X X X ╚ X ╝
	print-stdin <<-EOF2
                                 $(table-top)
                                 $(table-title "${1}")
                                 $(table-bottom)
	EOF2
}

@@ manual
:: 'Displays C-h r manual buffer'
function manual {
	save openfile
	declare-new-buffer
		:: line 1
		:: info "About"
		:: mode view
		:: filetype 'i*format'
		:: file "*about*"
		:: modified 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full
	get-manual
	redraw
}
	
@@ get-manual
:: Parses manual bml document
function get-manual {
	#DO NOT edit following lines, makedoc handles them automatically
	# MAKEDOC INSERT README START
mapfile -t -O 1 buffer <<EOF
$(text <<EOF2
This is Ebashs, one component of the Bash/Bash operating system.
… or even better an attempt to clone GNU Emacs in bash.
EOF2
)

$(text '    '<<EOF2
Note that the readme, may be currently outdated as I am changing the core functioning of Ebashs.

Versions of Ebashs ending in WIP-x are and will be broken, you can check version via M-x about or by reading the second line of Ebashs script.
EOF2
)

$(text '    '<<EOF2
For more updated help run inside Ebashs $(code 'M-x describe') or $(code 'C-h C-f')
EOF2
)

$(text <<EOF2
Update: Ebashs was split into two parts, the editor (Ebashs) and the underlying tui framework (Buffermaker). This split isn't yet complete and using Buffermaker for programs other than Ebashs is very experimental (see testapp example).

To continue using Ebashs also add buffermaker into PATH.
EOF2
)

$(header EBASHS)

$(title DESCRIPTION)

$(text <<EOF2
An attempt to clone GNU Emacs but in bash.
EOF2
)

$(title FEATURES)

$(text <<EOF2
syntax highlighting
custom keybindings
custom modes -- so you can implement the evil too
file picker
mouse support
EOF2
)

$(title CONFIG)

$(text <<EOF2
Ebashs is configured via variables defined at start, you can separate it into file and then source it.
EOF2
)

    $(title 'OPTIONS ARRAY')

$(table-init 3 19 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item mouse ' 0' 'enable mouse at launch')
    $(table-item todonote ' 1' "highlight 'TODO:' & 'NOTE:'")
    $(table-item menuline ' 1' 'display menuline')
    $(table-item tabchar "$(code '|   ')" 'what should tab display as')
    $(table-item file_prompt "'Path: '" 'file setting prompt')
    $(table-item cmd_prompt "'M-x '" 'command line prompt')
    $(table-item cancelhex "'18 0' (C-x)" 'keybinding to exit debug input menu')
    $(table-item default_mode ' edit' 'what mode should be set on launch')
    $(table-item help_message "'F10 to open menu'" 'top right help message')
    $(table-item dired_message "'Pick a file'" 'same as above but for dired buffer')
    $(table-bottom)
EOF2
)

    $(title 'KEYBINDING ARRAYS')

$(text '    ' <<EOF2
Keybinding arrays match with modes. The array has to be associative and nammed $(code 'keys_<mode>'). $(code 'keys_def') is reserved and used as reference for other arrays, it's also reversed compared to other keybinding arrays.
EOF2
)

$(text '     ' <<EOF2
Keybindings are defined via hexadecimal syntax suffixed with ' 0'. Function $(code '@kbd field') is equivalent to $(code '${keys_def[field]}') but nicer. Function kbd provides Emacsy keybinding syntax.
EOF2
)

$(text '    ' <<EOF2
There is also a optionable option array possible for all keybinding arrays. Currently only defined option is [else] which defines what should happen if no key is matched from the keybinding. These arrays have to be named $(code 'key_options_<mode>').
EOF2
)

    $(title MODES)

$(text '    ' <<EOF2
Modes determine used keybinding and other properties of buffer.
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DESCRIPTION)
    $(table-title-line)
    $(table-item edit "general editing mode")
    $(table-item dired "mode used in file picker")
    $(table-item view "read-only mode")
    $(table-item menu "mode of menus")
    $(table-item debuginput "for getting input codes (M-x input)")
    $(table-item prefix "for C-x prefix")
    $(table-item prefix_help "for C-h prefix")
    $(table-item quit "for quit confirmation")
    $(table-item list_buffers "used in buffer switcher")
    $(table-bottom)
EOF2
)

    $(title STYLE)

$(text '    ' <<EOF2
Style of stuff is defined as escape code. See extensions/gruvboxdark for example of custom theme.
EOF2
)

$(table-init 3 32 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item default ' \e[m' 'Default face')
    $(table-item TODO ' \e[0;97;45m' "Highlighting of 'TODO: '")
    $(table-item NOTE ' \e[0;97;100m' "Highlighting of 'NOTE: '")
    $(table-item menu ' \e[0;37;40' 'Menuline')
    $(table-item menu-enabled-face ' \e[0;37;40' 'Items of menuline')
    $(table-item selected ' \e[30;45m' 'Selected item')
    $(table-item link ' \e[94m' 'Redirects')
    $(table-item menu-selected-face ' \e[30;45m' 'Selected item of menu')
    $(table-item mode-line ' \e[40;97m' 'Bottom statusline')
    $(table-item line-number ' \e[0;90m' 'Line count')
    $(table-item line-number-empty ' \e[0;90m' 'Lines that do not exist')
    $(table-item line-number-current-line ' \e[0;91m' 'Currently selected line')
    $(table-item tab-face ' \e[0;90m' 'Tabs')
    $(table-item minibuffer-prompt ' \e[m' 'Bottom commandline')
    $(table-divider)
    $(table-item font-lock-variable-string-face ' \e[0;36;48m' 'Quoted variables')
    $(table-item font-lock-comment-face ' \e[3;37;48m' 'Comments')
    $(table-item font-lock-variable-name-face ' \e[0;96m' 'Variables')
    $(table-item font-lock-argument-face ' \e[0;93m' 'Options')
    $(table-item font-lock-flow-face ' \e[0;93m' 'Control flow')
    $(table-item font-lock-pipe-face ' \e[1;94m' 'Pipes')
    $(table-item font-lock-bracket-face ' \e[1;95m' 'Brackets')
    $(table-item font-lock-constant-face ' \e[0;92m' 'Constants')
    $(table-item font-lock-string-face ' \e[0;32m' 'Strings')
    $(table-item font-lock-assign-face ' \e[0;94;108m' 'Variable assignments')
    $(table-item font-lock-function-name-face ' \e[0;30;44m' 'Function definitions')
    $(table-item font-lock-declare-face ' \e[0;91m' 'Keywords')
    $(table-bottom)
EOF2
)
$(text '    ' <<EOF2
Ebashs also includes the ansi-color-* faces, see M-x list-faces-display for full list.
EOF2
)

    $(title SYNTAX)

$(text '    ' <<EOF2
Defines which syntax functions should be used for which file types.
EOF2
)

    $(title MENULINE)

$(text '    ' <<EOF2
Defines items in menuline, content of keys defines which functions should be ran on invocation.
EOF2
)

    $(title MENUS)

$(text '    ' <<EOF2
Each menu has to have helper function to set it up on request:
EOF2
)
$(code-block bash <<EOF2
        <menu>() { declare -ng menucon=<menu>; menu; }
EOF2
)
$(text '    ' <<EOF2
The contents of menu are defined by an associative  array.
EOF2
)

    $(title ALIAS)

$(text '    ' <<EOF2
Defines aliases that can be used in $(code 'M-x').
EOF2
)
$(text '    ' <<EOF2
Use function $(code add-alias name command) to define.
EOF2
)

$(title EXTENDING)

$(text <<EOF2
Some of useful variables and for extending Ebashs
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
$(table-top)
$(table-title NAME DESCRIPTION)
$(table-title-line)
$(table-item buffer 'File data')
$(table-item buffersyntax 'Multidimensional buffer for rendering')
$(table-item bufferexpand 'Special characters filtered out')
$(table-item bufferdata 'Options of current buffer')
$(table-item charmap 'Definitions for bufferexpand')
$(table-item mode 'Current mode')
$(table-item commands 'List of M-x commands')
$(table-bottom)
EOF2
)

$(title 'SYNTAX HIGHLIGHTING')

$(text <<EOF2
Ebashs handles highlighting via checking 'syntax' array which consists of $(code '[file type]=syntax-function')
EOF2
)

    $(title 'SYNTAX FUNCTIONS')

$(text '    ' <<EOF2
Here is sample bash syntax function included with Ebashs:
EOF2
)

$(code-block bash <<EOF2
    set-highlight
        :: shell bash ksh dash sh mksh zsh ash oksh i*bash

	defun syntax-shell
		:: Syntax function for shell
		:: Used faces:
		:: '    * font-lock-declare-face'
		:: '    * font-lock-variable-string-face'
		:: '    * font-lock-comment-face & sets comment to 1 for syntax-word function'
		:: '    * font-lock-variable-name-face'
		:: '    * font-lock-argument-face'
		:: '    * font-lock-function-name-face'
		:: '    * font-lock-flow-face'
		:: '    * font-lock-pipe-face'
		:: '    * font-lock-bracket-face'
		:: '    * font-lock-constant-face'
		:: '    * font-lock-string-face'
		:: '    * font-lock-assign-face'
		:: '    * font-lock-keyword-face'
		:: '    * font-lock-default-face'
		function =
			case "${word}" in
				*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
				'"$'*) set-face font-lock-variable-string-face;;
				'#'*) set-face font-lock-comment-face && comment=1;;
				'$'*) set-face font-lock-variable-name-face;;
				'-'*) set-face font-lock-argument-face;;
				*'()') set-face font-lock-function-name-face;;
				'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
				'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
				'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
				'function') set-face font-lock-function-name-face;;
				*"'"*) set-face font-lock-constant-face;;
				*'"'*) set-face font-lock-string-face;;
				*'='*) set-face font-lock-assign-face;;
				'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\\
					'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\\
					'let'|'shopt'|'trap'|'set'|'eval'\\
						) set-face font-lock-keyword-face;;
				*) set-face default;;
			esac
EOF2
)

$(text '    ' <<EOF2
The comments are handled specially via comment variable which gets reseted at every newline.
EOF2
)

$(title EXAMPLES)

$(text <<EOF2
A simple function to jump to line 11 when $(code 'C-x M-e') is pressed:
EOF2
)

$(code-block bash <<EOF2
    keys_prefix+=( # prefix is the mode for C-x
        [1b 65 0]='jump-to-11' # '1b 65 0' is the M-e in hex.
                               # You can use the M-x input to convert to hex. format.
    )
    jump-to-11() {
        [[ -n "${buffer[11]}" ]] && line=11 # If line 11 exists, set current line to 11.
        [[ "${bufferdata[mode]}" = 'prefix' ]] && quit-prefix
                                    # Since the key stroke contains C-x as prefix,
                                    # quit-prefix is is required as otherwise
                                    # it would stay in 'prefix' mode.
        redraw # Redraw whole buffer.
    }
EOF2
)

$(text <<EOF2
A function to write $(code 'Hello world!') at current cursor position when $(code 'M-x hi') is typed
EOF2
)

$(code-block bash <<EOF2
    commands+=(
        [hi]='hello-world' # Add command 'hi' invoking 'hello-world' function:
    )
    hello-world() {
        insert-word 'Hello-world!' # The function 'insert-word' handles insertion
                                   # of stuff, so no redraw or other magic is needed.
    }
EOF2
)

$(text '    ' <<EOF2
Create a menu containing previous functions $(code 'jump-to-11') & $(code 'hello-world'):
EOF2
)

$(code-block bash <<EOF2
    example-menu-function() { declare -ng menucon='example_menu'; menu; }
    # A function with which the menu will be invoked.

    declare -A example_menu
    example_menu=(
        [Jump to 11  ]='jump-to-11'  # The names of items in menu should have
        [Hello world!]='hello-world' # same width to display correctly.
    )

    # Add the example_menu into default menuline
    menulineedit+=(
        [Example]='example-menu-function'
    )
EOF2
)

$(title ETC)

$(text <<EOF2
Logo and it's krita file is in etc/

This readme is generated from doc/README.bml via makedoc script.
EOF2
)

$(title CREDITS)

$(text '    ' <<EOF2
Based on https://github.com/comfies/bed
EOF2
)

$(text '    '<<EOF2
fff by Dylan Araps https://github.com/dylanaraps/fff as base for extensions/efff
Licensed under the MIT license see extensions/efff for details
EOF2
)

$(text '    '<<EOF2
Early versions of Ebashs/Bano can be found at
https://github.com/aeknt/bashbox/blob/master/bin/nano
https://github.com/aeknt/bashbox/blob/master/bin/bano
EOF2
)
EOF
	# MAKEDOC INSERT README STOP
}

defun describe-function
	:: Displays help and info of function
	function = {
		redraw
		read-command 'Describe function: ' function || return 1
	    doc-select "$function"
	}

defun describe
	:: Displays help and info of all functions
	function = {
	    save openfiledoc
		declare-new-buffer
			:: line 9
			:: base 1
			:: column 0
			:: info "Documentation"
			:: mode format
			:: filetype 'format'
			:: file "*functions*"
			:: modified 0
			:: syntax syntax-format
			:: syntax-exec 1
			:: menuline 'dialog'
		size-full
		buffer=(
			''
		    "$format_nav"
			''
			'<f> title <u> Functions </u> </f>'
			'<i-tab>'
			'Documentation of these function is defined via internal pseudo-comments.'
			'It consists of the description and the source code. The source code is formated automatically'
			'by Bash and differs greatly from the formating of real source code.'
			'</i>'
)
		while read -r fn;  do
			buffer+=("<a> doc-select ${fn:11} : <f> link ${fn:11} </f> </a>")
		done <<< "$(declare -F)"
		buffer+=(
			''
			"<tab> <f> font-lock-comment-face Ebashs $version </f>"
		)
		redraw
}

defun doc-select	
	:: Select documentation item
	function = {
		local function="$@"
	    save openfile
		declare-new-buffer
			:: line 5
			:: info "Describe"
			:: mode format
			:: format-else quit-view
			:: filetype 'format'
			:: file "*describe*"
			:: modified 0
			:: syntax syntax-format
			:: syntax-exec 1
			size-full
		buffer=(
			''
			"$format_nav"
			''
		)
		mapfile -t -O 3 buffer <<< "$(get-description "$function")"
	    redraw
	}
nufed

@@ doc-goto
:: Replace function documentation with function \$1.
:: 'See <a> doc-goto get-description : <f> link get-description </f> </a> for more details.'
function doc-goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
    buffer=(
		''
		"$format_nav"
		''
	)
	mapfile -t -O 3 buffer <<< "$(get-description "$1")"
	redraw
}

defun quit-doc
	:: Quits and restores previous buffer.
	function = {
		restore openfiledoc
		redraw
	}

defun get-description
	:: Prints desciption of function \$1
	function = {
		is-function "$1" || {
			echo "<f> highlight $1 is not a Ebashs function </f>"
			return
		}
		printf "%s\n" "<f> title [ $1 ] </f>"
		[ -z "${descriptions[function_${1}_description]}" ] && {
			echo 'Function has no documentation'
			return
		}
		local -n fn_desc="${descriptions[function_${1}_description]}"
		((${#fn_desc[@]})) && {
			echo
			for l in "${fn_desc[@]}"; {
				printf "%s\n" "$l"
			}
			#for i in {0..8}; {
			#	printf '\n'
			#}
			#printf '<f> title [ Source ] </f>\n <change-syntax> 0 shell\n'		 
			#declare -f -- "$1"
		}
	}

defun quit-view
	:: Quits and restores previous buffer.
	:: Used mainly for dialog buffers.
	function = {
		restore openfile
		redraw
	}
nufed

@@ duplicate-line Copies line
function duplicate-line {
	newline # create new empty line
	buffer[bf_d[line]-1]="${buffer[bf_d[line]]}" # copy current line to previous line
	#make-render-area $((bf_d[line]-1)) $((bf_d[line]))
	local -n lap="${current_buffer}_syntax$((bf_d[line]-1))"
	local -n lac="${current_buffer}_syntax$((bf_d[line]))"
	copy-array lac lap
	redraw
}
	
@@ newline
:: Inserts newline to current buffer at current cursor position, shift lines
:: below one line down and go down one line.
function newline {
	bf_d[modified]=1
	save-state
	buffer=('' "${buffer[@]:1:${bf_d[line]}-1}" '' "${buffer[@]:${bf_d[line]}}")
	buffer[bf_d[line]]="${buffer[${bf_d[line]}+1]:0:${bf_d[column]}}"
	buffer[bf_d[line]+1]="${buffer[${bf_d[line]}+1]:${bf_d[column]}:${#buffer[${bf_d[line]}+1]}}"
	bf_d[column]=0
	syntax-shift
	no_cursor=1
	redraw
	no_cursor=0
	next-line
}

@@ syntax-shift
:: Moves syntax multibuffer from current cursor position one line to the bottom.
:: Used in newline function.
::
:: Is currently very badly implemented, TODO: fix.
function syntax-shift {
	local -a tmp1
	local -a tmp2
	local extmp1
	local extmp2
	for ((l=bf_d[line];l<${#buffer[@]}+1;l++)); do
		local -n linearray="${current_buffer}_syntax${l}"
		copy-array linearray tmp1
		copy-array tmp2 linearray
		copy-array tmp1 tmp2
		extmp1="${bf_e[l]}"
		bf_e[l]="$extmp2"
		extmp2="$extmp1"
	done
	bf_s[buffer_length]="${current_buffer}_syntax${bf_d[number-length]}"
	unset tmp1 tmp2
	make-render-area $((bf_d[line])) $((bf_d[line]+2))
}

defun delete-line
	:: Deletes line at current cursor position
	function = {
		bf_d[modified]=1
		buffer-delete-line "${bf_d[line]}"
		((bf_d[line] == 1)) || previous-line
		redraw
	}

defun buffer-delete-line
	:: Deletes line at \$1
	function = {
		local -i l=$1
		save-state
		buffer=("" "${buffer[@]:1:l-1}" "${buffer[@]:l+1}")
		bf_s=("" "${bf_s[@]:1:l-1}")
	}

fragment getrlr <<'+'
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
+

fragment predelete <<'+'
	((bf_d[selection])) && {
		delete-selection
		return
	}
	((${#buffer[${bf_d[line]}]} == 0 )) && {
		delete-line
		bf_d[column]="${#buffer[${bf_d[line]}]}"
		redraw
		return 0
	}
+

defun-fragment backspace
	:: Deletes previous character
	function = {
		save-state
		@ predelete
		@ getrlr
		((rlr==0)) && {
			buffer[bf_d[line]-1]="${buffer[bf_d[line]-1]}${buffer[bf_d[line]]}"
			delete-line
			bf_d[column]=${#bf_e[${bf_d[line]}]}
			redraw
			return 0
		}
		buffer[${bf_d[line]}]="${buffer[${bf_d[line]}]:0:$(( rlr - 1 ))}${buffer[${bf_d[line]}]:${rlr}}"
		backward-char #go back with cursor
		make-render-line # copy the buffer into bf_s and bf_e
		redraw #draw it
		bf_d[modified]=1
	}

defun-fragment delete
	:: Deletes next character
	function = {
		save-state
		@ predelete
		@ getrlr
		((rlr==${#buffer[bf_d[line]]})) && {
			buffer[bf_d[line]]="${buffer[bf_d[line]]}${buffer[bf_d[line]+1]}"
			move-next-line
			delete-line
			bf_d[column]=${#bf_e[${bf_d[line]}]}
			redraw
			return 0
		}
		buffer[bf_d[line]]="${buffer[bf_d[line]]:0:rlr}${buffer[bf_d[line]]:rlr+1:${#buffer[bf_d[line]]}}"
		make-render-line # copy the buffer into bf_s and bf_e
		redraw #draw it
		bf_d[modified]=1
	}

defun delete-selection
	:: Deletes region
	function = {
		_ sy bf_d[selection_start_y]
		_ ey bf_d[selection_end_y]
		_ sx bf_d[selection_start_x]
		_ ex bf_d[selection_end_x]
		((sy == ey)) && {
			((sx > ex)) && __ sx ex
			buffer[sy]="${buffer[sy]:0:sx}${buffer[sy]:ex}"
			bf_d[column]=$sx
			make-render-area $sy $((sy+1))
		} || {
			((sy > ey)) && {
				__ sy ey
				__ sx ex
			}
			buffer[sy]="${buffer[sy]:0:sx}"
			buffer[ey]="${buffer[ey]:ex}"
			buffer=("" "${buffer[@]:1:sy}" "${buffer[@]:ey}")
			bf_s=("" "${bf_s[@]:1:sy-1}")
			buffer[sy+1]="${buffer[sy]}${buffer[sy+1]}"
			buffer=("" "${buffer[@]:1:sy-2}" "${buffer[@]:sy}")
			bf_d[line]=$sy
			bf_d[column]=$sx
		}
		bf_d[selection]=0
		redraw
		_ # unset reference aliases
	}

defun write-buffer
	:: Writes current buffer into its target file	
	function =
		if [ -w "${bf_d[file]}" ]; then
			dump-buffer "${bf_d[file]}"
			bf_d[modified]=0
			message="Wrote ${#buffer[@]} lines to \'${bf_d[file]}\'"
		else
			return 1
		fi

add-mode quit
	local-set-key "$(kbd y)" 'save-quit'
	local-set-key "$(kbd n)" 'die'
	local-set-key "$(kbd c)" 'quit-quit'
	local-set-key "$(kbd C-y)" 'save-quit-force'

defun save-quit-force
	:: Force saving file
	function = {
		dump-buffer "${bf_d[file]}"
		die
	}
	
defun save-quit
	:: Writes buffer if target is writable
	function =
		if write-buffer; then
			die
		else
			message='File is not writable! [n/c] (to force save C-y)'
			redraw-commandline
		fi

defun quit-quit
	:: Quits quit message
	function = {
		bf_d[mode]="$bckmode"
		message='Quit canceled'
		redraw
	}

defun quit
	:: Displays quit message and sets mode to \'quit\'
	function = {
		[ -n "${bf_d[isfile]}" ] && ((bf_d[isfile]==0)) || ((bf_d[modified]==0)) && {
			die
		}
		
		[ -z "$bckmode" ] && bckmode="${bf_d[mode]}"
		bf_d[mode]='quit'
		redraw-statusline
		printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
		printf '%s' 'Buffer modified, save before close? [y/n/c]'
	}

defun set-mark-command
	:: Begins selection	
	function =
		if ((bf_d[selection])); then
			log info 'selection disable'
			bf_d[selection]=0
		else
			bf_d[selection]=1
			bf_d[selection_start_y]="${bf_d[line]}"
			bf_d[selection_start_x]="${bf_d[column]}"
			log info 'selection enable'
		fi

defun shell
	:: Spawns bash as subprocess
	function = {
		clear-screen
		bash # NOTE: in theory an external command
		redraw
	}

defun execute
	:: Executes a command and inserts its output into buffer	
	function = {
		((bf_d[line] == 0)) && return # If the line is not possible, do nothing
		printf '\e[?25h\e[%sH' "$((bf_d[line] + 2 - bf_d[base]))" # Reset cursor position and enable cursor
		read -re -p "$(printf '%4s ' "$")" # Present editable line
		if [[ "$REPLY" != "${buffer[${bf_d[line]}]}" ]]; then # If the line is changed, update and inform
			buffer[${bf_d[line]}]="$($REPLY)"
			bf_d[modified]=1
		fi
		make-render-line
		redraw
	}

defun diff-buffer-syntax
	:: Deletes highlighting on modified lines, comparing two buffers
	function = {
		# remove outdated lines from bf_s to set them for resyntaxing
		local -n source="$1"
		local -n target="$2"
		for idx in "${!target[@]}"; do
			[ "${source[idx]}" = "${target[idx]}" ] || bf_s[idx]=
		done
	}

defun diff-buffer-copy
	:: Compares two buffers and copies the difference into \$3 buffer
	function = {
		local -n source="$1"
		local -n check="$2"
		local -n target="$3"
		[ -z "${source[*]}" ] && return 1 # | indicate that there's no previous buffer state to check against 
		[ -z "${check[*]}"  ] && return 1 # | should indicate save-state() to just copy the whole buffer
		target=()
		for idx in "${!source[@]}"; do
			[ "${source[idx]}" = "${check[idx]}" ] || target[idx]="${source[idx]}"
			[ "${source[idx]}" = "${check[idx]}" ] && target[idx]=''
		done
	}

defun diff-buffer-merge
	:: Add buffer \$1 on top of \$2
	function = {
		local -n source="$1"
		local -n target="$2"
		for idx in "${!source[@]}"; do
			[ -n "${source[idx]}" ] && target[idx]="${source[idx]}"
		done
	}

defun save-state
	:: Saves current buffer for undo function
	function = {
		((bf_d[current_state]++))
		declare -ga "${current_buffer}_buffer_state_${bf_d[current_state]}"
		diff-buffer-copy\
			buffer\
			"${current_buffer}_buffer_state_$((bf_d[current_state]-1))"\
			"${current_buffer}_buffer_state_${bf_d[current_state]}" || {
			copy-array buffer "${current_buffer}_buffer_state_${bf_d[current_state]}"
		}
	}

defun undo
	:: Undo a change
	function = {
		((bf_d[current_state]--))
		((bf_d[current_state]<0)) && {
			bf_d[current_state]=0
			bf_d[modified]=0
		}
		diff-buffer-syntax buffer "${current_buffer}_buffer_state_${bf_d[current_state]}"
		diff-buffer-merge "${current_buffer}_buffer_state_${bf_d[current_state]}" buffer
		redraw
	}

defun toggle-mouse
	:: 'Changes options[mouse]'
	function =
		case "${options[mouse]}" in
			0)
				printf '\e[?1000;1006;1015h'
				options[mouse]=1
				message='Enabled options[mouse]';;
			1)
				printf '\e[?1000;1006;1015l'
				options[mouse]=0
				message='Disabled options[mouse]'
		esac

defun toggle-mode-line
	:: 'Changes options[mode-line]'
	function =
		case "${options[mode-line]}" in
			0)
				options[mode-line]=1
				((bottomlines++))
				redraw;;
			1)
				options[mode-line]=0
				((bottomlines--))
				redraw
		esac

defun toggle-command-line
	:: 'Changes options[command-line]'
	function =
		case "${options[command-line]}" in
			0)
				options[commandline]=1
				((bottomlines++))
				redraw;;
			1)
				options[command-line]=0
				((bottomlines--))
				redraw
		esac

defun toggle-line-number-mode
	:: 'Changes options[line-number-mode]'
	function = {
		case "${options[line-number-mode]}" in
			0) options[line-number-mode]=1;;
			1) options[line-number-mode]=0
		esac
		redraw
	}

defun toggle-menu-line
	:: 'Changes options[menu-line]'
	function = {
		case "${options[menu-line]}" in
			0) options[menu-line]=1;;
			1) options[menu-line]=0
		esac
		toplines="${options[menu-line]}"
		redraw
	}

defun-fragment insert-word
	:: Insert \$1 to buffer
	function = {
		save-state
		@ getrlr
		buffer[bf_d[line]]="${buffer[${bf_d[line]}]:0:${rlr}}$1${buffer[${bf_d[line]}]:${rlr}}"
		#add at cursor position - amount of tabs * tab size
		make-render-line
		forward-char "${#1}"
		bf_d[selection]=0
		redraw
		bf_d[modified]=1
	}
nufed
	
@fn self-insert 'insert-word $@'
@fn insert-space 'insert-word " "'
@fn indent-for-tab-command "insert-word '	'"

@@ load-config Sources custom config file
function load-config {
	log_buffer+=('LOADING CONFIG...')
	local config_file
	local f
	f=~/.config/ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	f=~/.config/ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	
	f="${EBASHS_CONFIG}" ;[ -n "$f" ] && [ -f "$f" ] && config_file="$f"
	f="${EBASHS_CONFIG_DIR}/init.bash" ;[ -n "$f" ] && [ -f "$f" ] && config_file="$f"
	
	[ -z "$config_file" ] && return
	source "$config_file"
	log_buffer+=("LOADED $config_file")
}

@@ scratch
:: Empty buffer
function scratch {
	log info "loading empty buffer..."
	declare-new-buffer
		:: mode "${options[default_mode]}"
		:: info "${options[help-message]}"
		:: filetype "bash"
		:: file "*scratch*"
		:: isfile 0
		:: menuline welcome
		:: current_state 0
	set-syntax
	size-full

	buffer=(
		''
		'# This buffer is for text that is not saved, and for Bash evaluation.'
		'# To create a file, visit it with C-x C-f and enter text in its buffer.'
		''
	)
		
	message="For information about Ebashs and the BASH system, type C-h C-a."
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ welcome-buffer
:: Show welcome message
function welcome-buffer {
	log info "loading welcome buffer..."
	declare-new-buffer
		:: mode welcome
		:: info "${options[help-message]}"
		:: filetype "format"
		:: file "*welcome*"
		:: isfile 0
		:: menuline welcome
		:: current_state 0
		:: syntax syntax-format
		:: syntax-exec 1
	size-full

	buffer=(
		''
		'<f> title <u> Ebashs </u> </f>'
		'<i-tab>'
		' Welcome to Ebashs the editor of pure Bash.'
		'</i>'
		'<f> title <u> Actions </u> </f>'
		'<tab> <a> find-file : <f> red Open <f> title f </f-> ile </f> </a>'
		'<tab> <a> dired : <f> yellow <f> title B </f-> rowse files </f> </a>'
		'<tab> <a> manual : <f> green View <f> title m </f-> anual </f> </a>'
		'<tab> <a> view-page : <f> cyan View <f> title d </f-> ocumentation </f> </a>'
		'<tab> <a> about : <f> blue <f> title A </f-> bout Ebashs </f> </a>'
		'<tab> <a> inputcodes : <f> magenta <f> title I </f-> nput debugging </f> </a>'
		'<tab> <a> list-faces-display : <f> red Fa <-f> title c </f-> es </f> </a>'
	)
	((log)) && buffer+=(
		'<tab> <a> view-log : <f> yellow <f> title L </f-> og </f> </a>'
	)
		
	message="For information about Ebashs and the BASH system, type C-h C-a."
	bf_d[line]=1 # Indicate that we have a buffer loaded
	bf_d[modified]=0
}

@@ init
:: Prepares variables and launches main function
function init {
	case "$1" in
		'--quick'|'-Q')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			load-default-config
			shift;;
		'--version')
			echo "$version"
			abort;;
		'--dump')
			declare -f
			echo 'init "$@"'
			abort;;
		'--help')
			print-stdin <<EOF
Usage: ebashs [OPTION-OR-FILENAME]...

Run Ebashs, the extensible, customizable, maybe-real-time
display editor.  The recommended way to start Ebashs for normal editing
is with no options at all.

Run C-h r RET inside Ebashs to read "manual".

Initialization options:
--quick, -Q    don't load config
--help,        display this help and exit
--version,     display version information and exit
--view, -v     open file for viewing if possible
--exec, -e     execute file as script with Ebashs features
EOF
			abort;;
		'--view'|'-v')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			options[view]=1
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
			shift;;
		'--exec'|'-e')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			options[view]=1
			options[no-file]=1
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
			source "$2"
			shift;;
		*)
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			load-default-config
			load-default-config-ebashs #loads default config
			load-config
	esac
	init-var
	
	if [[ "$1" ]]; then # If a file was provided in the terminal pre-load it
		log info "args: $1"
		if [ -d "$1" ]; then
			log info "[$1] is directory => dired"
			cd "$1" || exit
			dired # enter the file selector in specified folder
		else
			log info "[$1] is file => read-buffer"
			read-buffer "$1"
		fi
	else
		log info "no arg => scratch"
		if ((options[welcome-buffer])); then
			welcome-buffer
		else
			scratch
		fi
	fi
	log info "drawing..."
	redraw
	log info 'entering main loop...'
	main
}

log_buffer+=('INIT')
init "$@"
