#!/bin/bash
printf '\e[?7l'
shopt -s lastpipe # For syntax
shopt -s extglob # Ensure advanced pattern matching is available

declare -A syntax menuline menufile menuhelp menukey menudebug style windowkey editkey keys_edit keys_def options charmap menufancy
declare -a buffer buffersyntax bufferexpand hexkey optdc
declare -i line base rl offsetst offseten menulinep menulinepy
declare -n menucon window
declare file message modified filetype comment stringone stringtwo reservedlines recmd rst

printf "\e[?1049h" #switch to alternative buffer

version="Spis dev"
buffer=() # File contents
buffersyntax=() # File contents
line=0 # Currently selected line (0 means the buffer is empty)
base=1 # Top-most line shown
rl=0 # how left or right the cursor is
menulinepy=0; menulinep=0 # menu positions
file= # Currently addressed file
message="${version}: insanity" # Feedback text in the status bar
modified=false # Tracking whether a file was modified
reservedlines=2 # Number of lines not displaying file

## config options

options=(
	[mouse]=false
	[todonote]=true
	[defx]=$(( COLUMNS / 2 ))
	[defy]=$(( LINES /2 ))
	[timeout]=0.01
	[tabchar]=' →  '
	[refresh_timeout]=1
	[file_prompt]="Path: "
	[button_margin]=2
	[button_padding]=4
	[cancelhex]='18 0'
)
keys_def=(
	[up]='1b 5b 41 0'
	[down]='1b 5b 42 0'
	[right]='1b 5b 43 0'
	[left]='1b 5b 44 0'
	[select]='0'
)
keys_edit=(
	[${keys_def[up]}]='up'
	[${keys_def[down]}]='down'
	[${keys_def[right]}]='right'
	[${keys_def[left]}]='left'
	[1b 5b 42 0]='down'
	[1b 5b 43 0]='right'
	[1b 5b 44 0]='left'
	[1b 5b 35 7e 0]='page_up'
	[1b 5b 36 7e 0]='page_down'
	[18 0]='quit'
	[7 0]='menulinemenu'
	[10 0]='up'
	[e 0]='down'
	[6 0]='right'
	[2 0]='left'
	[10 0]='page_up'
	[16 0]='page_down'
	[0]='new_line'
	[c 0]='new_line'
	[f 0]='write_buffer'
	[12 0]='read_buffer'
	[1b 72 0]='set_buffer_file'
	[14 0]='execute'
	[4 0]='delete_line'
	[13 0]='shell'
	[5 0]='mtoggle'
	[7f 0]='backspace'
	[1b 71 0]='die'
	[1b 67 0]='menukey'
)
style=(
	[TODO]='\e[0;97;45m'
	[NOTE]='\e[0;97;100m'
	[menuline]='\e[0;37;40m'
	[windowline]='\e[0;97;100m'
	[menuitem]='\e[0;37;40m'
	[windowcontent]='\e[97;40m'
	[selected]='\e[30;45m'
	[button]='\e[0;97;100m'
	[interactive]='\e[95;40m'
	[menuitemselected]='\e[30;45m'
	[infoline]='\e[40;97m'
	[number]='\e[0;37m'
	[numberempty]='\e[0;90m'
	[numberselected]='\e[0;93m'
	[tab]='\e[0;90m'
	#syntax
	[quotevar]='\e[0;36;48m'
	[comment]='\e[3;37;48m'
	[variable]='\e[0;96m'
	[option]='\e[0;93m'
	[flow]='\e[0;93;m'
	[bracket]='\e[1;95m'
	[quote]='\e[0;92m'
	[dquote]='\e[0;32m'
	[set]='\e[0;94;108m'
	[fn]='\e[0;30;44m'
	[keyword]='\e[0;91m'
)
#TODO: this will be usesfull for later implementation of ligatures and stuff
charmap=(
	#[0] is reserved for any unmapped char
	[	]='t'
	#[	-render]="${options[tabchar]}"
)
windowkey=(
	[up]=$'\E[A'	[down]=$'\E[B'	[right]=$'\E[C'	[left]=$'\E[D'
	[hsizep]='*'	[hsizem]='/'	[vsizep]='+'	[vsizem]='-'
)

menulinemenu() {
	unset menucon
	declare -n menucon=menufancy
	#menulinepy=$(( LINES - ${#menufancy[@]} ))
	menu
}
menuline=(
	[File]=menufile	[Help]=menuhelp
	[Keys]=menukey	    [Redraw]=refresh
	[Debug]=menudebug
)

for item in "${!menuline[@]}"; do
	menufancy+=(["$(printf '%-12s' "$item")"]="${menuline["$item"]}")
done
menufancy+=([Quit        ]=quit)

menufile() { unset menucon; declare -n menucon=menufile; menu; }
menufile=(
	[Quit    C-x  ]="quit"
	[Open loc M-r ]="set_buffer_file"
	[Execute  C-t ]="execute"
	[Save     C-o ]="write_buffer"
	[File picker  ]="filepick"
	[Info         ]="wininfo"
)

menuhelp() { unset menucon; declare -n menucon=menuhelp; menu; }
menuhelp=(
	[Keybinding          ]=menukey
	[About float windows ]=winhelpf
	[About               ]=about
)

menukey() { unset menucon; declare -n menucon=menukey; menu; }
menukey=(
	[Exit         C-x ]="quit"
	[New Line C-l | ⏎ ]="new_line"
	[Set target   M-r ]="set_buffer_file"
	[Read File    C-r ]="read_buffer"
	[Write Out    C-o ]="write_buffer"
	[Delete Line  C-d ]="delete_line"
	[Toggle Mouse C-e ]="mtoggle"
	[Prev Line    C-p ]="up"
	[Next Line    C-n ]="down"
	[Prev Page    C-y ]="page_up"
	[Next Page    C-v ]="page_down"
	[Execute      C-t ]="execute"
	[Shell        C-s ]="shell"
	[Exit no save M-q ]="die"
)

menudebug() { unset menucon; declare -n menucon=menudebug; menu; }
menudebug=(
	[clear      ]=clr
	[refresh    ]=refresh
	[screen init]=scrinit
	[backspace  ]=backspace
	[right      ]=right
	[left       ]=left
	[dialogquit ]=dialogquit
	[inputcodes ]=inputcodes
	[debugmenu  ]=debugmenutest
)

syntax=(
	[bash]=builtin_syntax_bash	[sh]=builtin_syntax_bash
	[ksh]=builtin_syntax_bash	[mksh]=builtin_syntax_bash
	[dash]=builtin_syntax_bash	[zsh]=builtin_syntax_bash
	[conf]=builtin_syntax_conf	[unknown]=builtin_syntax_unknown
)

declare -A about
about() { unset window; declare -n window=about; float; }
about=(
	[sizex]="${options[defx]}"	[sizey]="${options[defy]}"
	[title]=" About ${version} "
	[content]="${version}, text \"editor\" written bash. git repo: https://github.com/nyeta/spis; originally based on https://github.com/comfies/bed"
)

declare -A winhelp
winhelpf() { unset window; declare -n window=winhelp; float; }
winhelp=(
	[sizex]="${options[defx]}"	[sizey]="${options[defy]}"
	[title]=" Floating window help "
	[content]="Use tab key to switch focus. When focused on window itself use arrow keys to move the window and / to decrease its width, * to increase, + to increase its height and - to decrease. When focused on choose menu, use left and right arrow to select.  -- for now this is absolutelly useless"
)

declare -A wininfo
wininfo() { unset window; declare -n window=wininfo; wininfo[content]="name: $file; type: $filetype"; float; }
wininfo=(
   	[sizex]="${options[defx]}"	[sizey]="${options[defy]}"
	[title]=" File info "
	#content is set in fucntion, so it can dynamicaly update
)

declare -A dialogquit dialogquitmenu
dialogquit() { unset window; declare -n window=dialogquit; float; }
dialogquit=(
	[sizex]=46 [sizey]=8
	[title]="Unsaved work"
	[content]="Buffer modified, save before close?"
	[type]="choose"
	[options]="dialogquitmenu"
	[layout]="center"
	[default]="save"
	[focus]="choose"
)
dialogquitmenu=(
	[save]="write_buffer; die"
	[quit]="die"
	[cancel]="redraw; return 69"
)

declare -A debugmenutest debugmenutestch
debugmenutest() { unset window; declare -n window=debugmenutest; float; }
debugmenutest=(
	[sizex]="${options[defx]}" [sizey]="${options[defy]}"
	[title]="Test"
	[content]="Pick!"
	[type]="choose"
	[options]="debugmenutestch"
	[layout]="right"
	[default]="menudebug"
	[focus]="choose"
)
debugmenutestch=(
	[menudebug]="menulinepy=menudebug"
	[menukey]="menukey"
	[menuhelp]="menuhelp"
)

## rest of this garbageware

rst='\e[0;0m'
clr() {
	printf "\033c" # clear
}

# getting the cursor position
getcy() {
	local pos
	IFS='[;' read -p $'\e[6n' -d R -a pos -rs || echo "failed with error: $? ; ${pos[*]}"
	echo "${pos[1]}"
}
getcx() {
	local pos
	IFS='[;' read -p $'\e[6n' -d R -a pos -rs || echo "failed with error: $? ; ${pos[*]}"
	echo "${pos[2]}"
}


refresh() {
	clr
	message="reloaded..."
	megaredraw
	redraw
	scrinit
	message=
}
scrinit() {
	printf '\e[?1047h' # Switch to alternative buffer
    [ "${options[mouse]}" = true ] && echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
}

float() {
	local -i dci=0
	change=true
	floatsizex="${window[sizex]}"
	floatsizey="${window[sizey]}"
	floatpositionx=$(( ( COLUMNS / 2 ) - ( floatsizex / 2 )  ))
	floatpositiony=$(( ( LINES / 2 ) - ( floatsizey / 2 ) ))
	if [ -z "${window[focus]}" ]; then
		focus=window
	else
		focus="${window[focus]}"
	fi
	case "${window[type]}" in
		'choose')
			unset chooseopt
			declare -n chooseopt="${window[options]}"
			declare -n layout="${window[layout]}"
			selopt="${window[default]}"
			for is in "${!chooseopt[@]}"; do
				optdc[dci]="$is"
				if [ "$is" = "${selopt}" ]; then
					   seloptdc=$dci
				   fi
				((dci++))
			done
			;;
	esac
	floatwin
}
floatwin() {
	while true; do
		[ "$change" = true ] && {
			redraw
			printf '\e[%s;%sH' $floatpositiony $floatpositionx
			printf "${style[windowline]}%*s\r" $floatsizex
			printf '\e[%s;%sH' $floatpositiony $floatpositionx
			printf '%s\e[m' "${window[title]}"
			local -i rsizey=$(( floatsizey - 1 ))
			local -i csizex=0
			for ((i=1;i<=rsizey;i++)); do
				printf "\e[%s;%sH${style[windowcontent]}%*s\r" $(( floatpositiony + i )) $floatpositionx "$floatsizex"
				printf '\e[%s;%sH%s\n' $(( floatpositiony + i )) $floatpositionx "${window[content]:csizex:floatsizex}"
				csizex=$(( csizex + floatsizex ))
			done
			#draw selection menu
			case "${window[type]}" in
				'choose')
					floatchoose;;
			esac
		}
		winkey
		[ $? = 69 ] && return
	done
}
floatchoose() {
	local -i bm=${options[button_margin]}
	local -i bp=${options[button_padding]}
	local all="${!chooseopt[*]}"
	case "${window[layout]}" in
		right)
			local -i stx=$((floatpositionx + floatsizex - ${#all} - ${#chooseopt[*]} * 2 * bp - ${#chooseopt[*]} * ( bm - 1 ) - 1));;
		left)
			local -i stx=$((floatpositionx + bm));;
		center)
			local -i stx=$((floatpositionx + (floatsizex / 2) - ( (${#all} + ${#chooseopt[*]} * 2 * bp + ${#chooseopt[*]} * (bm - 1) ) / 2 ) ));;
	esac
	local -i sty=$((floatpositiony + floatsizey - 2))
	floatchbpbm
	((sty--))
	(
		for opt in ${!chooseopt[@]}; do
			printf '\e[%s;%sH' $sty $stx
			if [ "$opt" = "$selopt" ]; then
				printf "${style[selected]}%*s${opt}%*s" $bp ' ' $bp ' '
			else
				printf "${style[button]}%*s${opt}%*s" $bp ' ' $bp ' '
			fi
		    stx=$((stx + ${#opt} + bp * 2 + bm))
		done
	)
	((sty--))
	floatchbpbm
	((sty++))
	(
		for opt in ${!chooseopt[@]}; do
			printf '\e[%s;%sH' $sty $stx
			if [ "$opt" = "$selopt" ]; then
			    printf '\e[%sC' $bp
				break
			fi
			stx=$((stx + ${#opt} + bp * 2 + bm))
		done
	)
	
}
floatchbpbm() {
	(
		for opt in ${!chooseopt[@]}; do
			printf '\e[%s;%sH' $sty $stx
			if [ "$opt" = "$selopt" ]; then
				printf "${style[selected]}%*s" $(( ${#opt} + bp * 2 ))
			else
				printf "${style[button]}%*s" $(( ${#opt} + bp * 2 ))
			fi
			stx=$((stx + ${#opt} + bp * 2 + bm))
		done
	)
}
winkey() {
	change=true
	printf '\e[m'
	local -a kbd=()
	if read -rsN1 kbd[0]; then # Check for ready input
		while read -rsN1 -t0.0001 kbd[$i]; do ((i++)); done # Multibyte hack
		case "$focus" in
			window)
				case "$(printf '%s' "${kbd[@]}")" in
					"${windowkey[up]}"*) ((floatpositiony--)) && (( floatpositiony < 1 )) && floatpositiony=1 && change=false ;;
					"${windowkey[down]}"*) ((floatpositiony++)) && (( floatpositiony > LINES - floatsizey )) && floatpositiony=$(( LINES - floatsizey )) && change=false ;;
					"${windowkey[right]}"*) ((floatpositionx++)) && (( floatpositionx > 1 + COLUMNS - floatsizex )) && floatpositionx=$(( 1 + COLUMNS - floatsizex )) && change=false ;;
					"${windowkey[left]}"*) ((floatpositionx--)) && (( floatpositionx < 1 )) && floatpositionx=1 && change=false ;;
					"${windowkey[vsizem]}") ((floatsizey--)) ;;
					"${windowkey[vsizep]}") ((floatsizey++)) ;;
					"${windowkey[hsizem]}") ((floatsizex--)) ;;
					"${windowkey[hsizep]}") ((floatsizex++)) ;;
					'	') true;;
					*) redraw; return 69;;
				esac
				;;
			choose)
				case "$(printf '%s' "${kbd[@]}")" in
					"${windowkey[right]}"*) ((seloptdc++)); (( seloptdc > ( ${#chooseopt[*]} - 1 ) )) && seloptdc=$(( ${#chooseopt[*]} - 1 ));;
					"${windowkey[left]}"*) ((seloptdc--)); ((seloptdc<0)) && seloptdc=0;;
					'')
						menulinepy=$(getcy)
						menulinep=$(getcx)
						eval "${chooseopt[$selopt]}";;
				esac
				selopt="${optdc[seloptdc]}"
				;;
		esac
		case "$(printf '%s' "${kbd[@]}")" in
			'	')
				case "${window[type]}" in
					'choose')
						if [ $focus = window ]; then
							focus=choose
							selopt="${optdc[seloptdc]}"
						else
							focus=window
							selopt=''
						fi
						;;
				esac
				;;
		esac
	fi
}

pipesyntax() {
	comment=false
	#stringone=false
	#stringtwo=false
	word=
	bckIFS="${IFS}"
	IFS=
	readstuff() {
		while read -rsn1 char
		do
			[ "$char" = " " ] && syntax && word='' && printf ' ' && continue
			[ "$char" = "	" ] && {
				syntax
				word=''
				printf "${style[tab]}%s\e[0;0m" "${options[tabchar]}"
				continue
			}
			[ -z "$char" ] && syntax && word='' comment='false' && echo && continue
			word="${word}${char}" && printf '%s\e[%sD' "$word" "${#word}"
		done
	}
	readstuff
	IFS="${bckIFS}"
}

builtin_syntax_bash() {
	case "${word:0:2}" in
		'"$') printf "${style[quotevar]}%s${rst}" "${word}"; return ;;
	esac
	case "${word:0:1}" in
		'#') printf "${style[comment]}%s${rst}" "${word}" && comment=true; return;;
		'$') printf "${style[variable]}%s${rst}" "${word}"; return ;;
		'-') printf "${style[option]}%s${rst}" "${word}"; return ;;
	esac
	"${comment}" && printf "${style[comment]}%s${rst}" "${word}" && return
	case "${word}" in
		'||') printf "${style[flow]}%s${rst}" "${word}"; return ;;
		'&&') printf "${style[flow]}%s${rst}" "${word}"; return ;;
		']') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		'[') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		'[[') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		']]') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		')') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		'(') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		'{') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		'}') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		';') printf "${style[flow]}%s${rst}" "${word}"; return ;;
		*"'"*) printf "${style[quote]}%s${rst}" "${word}" && return ;;
		*'"'*) printf "${style[dquote]}%s${rst}" "${word}"&& return ;;
		*'='*) printf "${style[set]}%s${rst}" "${word}"; return ;;
	esac
		   
	[[ "${word: -2}" = '()' ]] && printf "${style[fn]}%s${rst}" "${word}" && return
	case "${word}" in
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|'declare'|'typeset'|'local'|'let'|'shopt'|'trap'|'set'|'eval') printf "${style[keyword]}%s${rst}" "${word}" && return
	esac
	printf "${rst}%s" "${word}"
}
builtin_syntax_unknown() {
	printf "${rst}%s" "${word}"
}
builtin_syntax_conf(){
	[[ "${word}" =~ "#" ]] && printf "${style[comment]}%s${rst}" "${word}" && comment=true && return
	"${comment}" && printf "${style[comment]}%s${rst}" "${word}" && return
	printf "${rst}%s" "${word}"
}

syntax() {
	for s in "${!syntax[@]}"; do
		[ "$s" = "$filetype" ] && {
			[ "${options[todonote]}" = true ] && {
				case "$word" in
					'NOTE:') printf "${style[NOTE]}%s${rst}" "${word}"; return ;;
					'TODO:') printf "${style[TODO]}%s${rst}" "${word}"; return ;;
				esac
			}
			"${syntax[$s]}"
		} && return
	done
	"${syntax[unknown]}"
}

topline() {
	local -i ln=${#1}
	printf "${style[windowline]}%s\e[?25l%*s\r" "$1" "$(( $COLUMNS - ln ))"
}

inputcodes() {
	debuginput
	while true; do
		local -a k=()
		local -i i=1
		[ "${options[mouse]}" = true ] && echo -ne "\e[?1000;1006;1015h"
		if read -rsN1 -t${options[refresh_timeout]} k[0]; then # Check for ready input
			while read -rsN1 -t0.0001 k[$i]; do ((i++)); done # Multibyte hack
			debuginput "$(printf '%s' "${k[@]}")" # Handle keypress event
			[ $? = 69 ] && break
		fi
	done
	redraw
}
debuginput() {
	hexkey=()	
	i=0
	echo "$1" | while read -rsn1; do
		hexkey[i]="$(printf "%x\n" "'${1:$i}")"
		((i++))
	done
	if [ "${hexkey[*]}" = "${options[cancelhex]}" ]; then
	   return 69
	fi
	clr
	topline "Input codes (exit keybind is ${options[cancelhex]})"
	printf "${style[windowcontent]}"
	printf "\033[2;0H"
	for ((i=2;i<=LINES;i+=1)); do
		printf '\033[%s;0H' $i
		printf '%*s' "$COLUMNS"
	done
	printf "\033[2;0H"
	echo "${hexkey[@]}"
}

basenam() {
	for file in "$@"; do
	    file="${file%/}"
	    printf '%s\n' "${file##*/}"
	done
}
filetype(){
	[ $# = 0 ] && return
	IFS='.'
	filename="${1%/}"
	filename="${filename##*/}"
	[ "$filename" = 'COMMIT_EDITMSG' ] && echo conf && return
	filenamesplit=($filename)
	extension="${filenamesplit[-1]}"
	[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && return
	mapfile -n 1 file_data < "$1"
	shebang="$(echo -n "${file_data[@]}")"
	[ ! "${shebang:0:1}" = '#' ] && echo unknown && return
	shebang="${shebang%/}"
	IFS=' '
	shebang="${shebang##*/}"
	shebangsplit=($shebang)
	printf '%s\n' "${shebangsplit[-1]}"	
}
set_buffer_file() {
	printf '\e[%s;0H' "${LINES}"
	printf '\e[D\033[1;93;108m' #make prompt nicer
    bind 'set disable-completion off' 2>/dev/null # Enable completion
    printf '\e[?25h' # Enable cursor
    if read -rei "$1$file" -p "${file_prompt}" file; then
        modified=true
    fi
    bind 'set disable-completion on' 2>/dev/null
}
read_buffer() {
	filetype="$(filetype "$1")"
    #set_buffer_file "$1" # Update target file (pass on default if present)
	file="$1"
    mapfile -t -O 1 buffer <"$file" # Read file into an array
    pipesyntax < "$file" | mapfile -t -O 1 buffersyntax
    charexpand < "$file" | mapfile -t -O 1 bufferexpand
    if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
        line=1 # Indicate that we have a buffer loaded
        modified=false
        message="${file}: ${#buffer[@]}"
    else
        message="{$file}: empty"
    fi
}
pickprep() {
	clr
    topline "Open file..."
	printf "${style[windowcontent]}\n"
	for ((i=3;i<=$LINES;i+=1)); do
		printf '%*s\n' "$COLUMNS"
	done
	printf "${style[infoline]}\e[?25l%*s\r" "$COLUMNS"
	printf 'bottom info bar'
	printf "${style[windowcontent]}"
	printf "\033[2;0H"
}
filepick() {
	dc=0
	offsetst=0
	local -i ik=1
	pickprep
	pickdraw
	local -a kb=()
	while true; do
		if read -rsN1 -t"${options[timeout]}" kb[0]; then # Check for ready input
			while read -rsN1 -t0.0001 kb[$ik]; do ((ik++)); done # Multibyte hack
			makehexkey "$(printf '%s' "${kb[@]}")"
			case "${hexkey[*]}" in
				"${keys_def[up]}") ((dc--)) ;;
				"${keys_def[down]}") ((dc++)) ;;
				"${keys_def[select]}")
					#return to starting dir
					if [ -d "${direc[dc]}" ]; then
						cd "${direc[dc]}"
						offsetst=0
						dc=0
						pickprep
					else
						printf '\e[?1047h' # Switch to alternative buffer
						echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
						read_buffer "${direc[dc]}"
						redraw
						break
					fi
					;;
				*) continue;;
			esac
			(( "$dc" > ( "${#direc[@]}" - 1))) && ((dc--)) && continue
			(( "$dc" < 0 )) && ((dc++)) && continue
			(( "$dc" > ( LINES - 5 + offsetst ) )) && ((offsetst++))
		    (( "$dc" < ( 2 + offsetst ) )) && ((offsetst--))
		fi
		kb=()
		pickdraw
		printf "\033[%s;0H" $LINES
		printf "${style[infoline]}\e[?25l%*s\r" "$COLUMNS"
		printf '%s:%s' "$dc" "${direc[dc]}"
	done
}
pickdraw() {
	printf "\e[1;0H"
	printf "${style[windowline]}%s\e[?25l%*s\r" "Open file..." "$(( $COLUMNS - 12 ))"
	printf "${style[windowcontent]}\n"
	direc=($(pickls))
	offseten=$(( offsetst + ( LINES - 2 ) ))
	for il in "${!direc[@]}"; do
		if [ $il -ge $offsetst ] && [ $il -lt $offseten ]; then
			if [ $dc = $il ]; then
				printf "${style[selected]}\e[?25l%*s\r" "$COLUMNS"
				printf "%s\n" "${direc[il]}"
			else
				if [ -d "${direc[il]}" ]; then
					printf "${style[interactive]}\e[?25l%*s\r" "$COLUMNS"
					printf "%s\n" "${direc[il]}"
				else
					printf "${style[windowcontent]}\e[?25l%*s\r" "$COLUMNS"
					printf "%s\n" "${direc[il]}"
				fi
			fi
		fi
	done
	printf "${style[windowcontent]}\e[?25l%*s\r" "$COLUMNS" #fixes some stuff
}
pickls() {
	printf '..\n'
	printf '%s\n' *
}

write_buffer() {
    true >"$file" # Set the file to an empty text file
    for ln in "${buffer[@]}"; do # Write in the buffer to the file
        echo "$ln" >>"$file"
    done
    modified=false
    message="Wrote ${#buffer[@]} lines to '$file'"
}

megaredraw(){
	printf '%s\n' "${buffer[@]}" | pipesyntax | mapfile -t -O 1 buffersyntax
	printf '%s\n' "${buffer[@]}" | charexpand | mapfile -t -O 1 bufferexpand
}
megaredrawline(){
	buffersyntax[line]="$(printf '%s' "${buffer[line]}" | pipesyntax)"
	bufferexpand[line]="$(printf '%s' "${buffer[line]}" | charexpand)"
}

charexpand() {
	bckIFS="${IFS}"
	IFS=
	while read -rsn1 char
	do
		[ "$char" = "	" ] && {
			local -i i
			for ((i = ${#options[tabchar]}; i > 0 ; i--)); {
				printf '%s' "${charmap[	]}"
			}
			continue
		}
		[ -z "$char" ] && echo && continue
		printf '0'
	done
	IFS="${bckIFS}"
}
tabrenderraw(){
	IFSbck="$IFS"
	IFS=
	while read -rsn1 char
	do
		[ "$char" = " " ] && printf ' ' && continue
		[ "$char" = "	" ] && printf '%s' "${options[tabchar]}" && continue
		printf '%s' "$char"
	done
	IFS="$IFSbck"
}

new_line() {
    buffer=("" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
    unset 'buffer[0]'
    modified=true
	buffer[line+1]=${buffer[line]:rl:${#buffer[line]}}
	buffer[line]=${buffer[line]:0:rl}
	rl=0
	megaredraw
	down
	redraw
}

delete_line() {
    buffer=("" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
    unset 'buffer[0]'
    ((line > ${#buffer[@]})) && up
    modified=true
    megaredraw
	redraw
}

backspace() {
	if [ "${#buffer[line]}" = 0 ]; then
		delete_line
		rl="${#buffer[line]}"
		redraw
		return 0
	fi
	local -i rlr
	unset ta
	local ta
	ta=${bufferexpand[line]:0:rl}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((rl + ta / 4 - ta))
	if [ $rlr = 0 ]; then
		buffer[line-1]="${buffer[line-1]}${buffer[line]}"
		delete_line
		rl=${#bufferexpand[line]}
		redraw
		return 0
	fi
	buffer[line]="${buffer[line]:0:$(( rlr - 1 ))}${buffer[line]:${rlr}}"
	left #go left with cursor
	megaredrawline #not sure why this is needed but it prevents duplication of the letter
	redraw #draw it
	modified=true
}

quit() {
	if [[ "$modified" == "true" ]]; then
		dialogquit
	else
		die
	fi

}

up() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line > 1)) && ((line--)) # As long as we can keep going up, go up
        ((line < base)) && ((base--)) && # Push back the top if we need to
        ((base <= 0)) && base=1 # Don't push back if our base is at 1
        [ -z "$bckrl" ] && bckrl="${rl}"
        (( "${#buffer[line]}" < "${rl}" )) && rl="${#buffer[line]}"
        (( "${#buffer[line]}" > "${rl}" )) && rl=bckrl
    done
	redraw
}

page_up() {
    up $((LINES - 3))
}

down() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line < ${#buffer[@]})) && ((line++)) # If we can go down, go down
        ((line > base + LINES - 3)) && ((base++)) && # Move window down if needed
        [ -z "$bckrl" ] && bckrl="${rl}"
        (( "${#buffer[line]}" < "${rl}" )) && rl="${#buffer[line]}"
        (( "${#buffer[line]}" > "${rl}" )) && rl=bckrl
    done
	redraw
}

page_down() {
    down $((LINES - 3))
}

execute() {
    ((line == 0)) && return # If the line is not possible, do nothing
    printf '\e[?25h\e[%sH' "$((line + 2 - base))" # Reset cursor position and enable cursor
    read -re -p "$(printf '%4s ' "$")" # Present editable line
    if [[ "$REPLY" != "${buffer[line]}" ]]; then # If the line is changed, update and inform
        buffer[line]="$($REPLY)"
        modified=true
    fi
    megaredraw
    redraw
}
drawc() {
	printf '\e[?25h\e[%s;%sH' $((line + 2 - base)) $(( rl + 6 )) # move cursor to the line
}
right() {
	case "${bufferexpand[line]:rl+1:1}" in
		't') rl=$(( rl + ${#options[tabchar]}));;
		*) ((rl++));;
	esac
	[ "$rl" -gt "${#bufferexpand[line]}" ] && { rl=0; down; }
	bckrl=
	#redraw
	drawc
}
left() {
	case "${bufferexpand[line]:rl-1:1}" in
		't') rl=$(( rl - ${#options[tabchar]}));;
		*) ((rl--));;
	esac
	[ "$rl" -lt 0 ] && { up; rl="${#bufferexpand[line]}"; }
	bckrl=
	drawc
}
shell() {
	printf "\033c"
	bash
	redraw
}

die() {
    bind 'set disable-completion off' 2>/dev/null # Enable completion
    printf '\e[?25h\e[?7h\e[?1047l' # Reset terminal to sane mode
    printf "\e[?1049l" # switch back to main buffer
    echo -e "\e[?1000;1006;1015l" #disable mouse tracking
    exit "${errno:-0}" # Assume that we are exiting without an error
}
mtoggle() {
	[ "${options[mouse]}" = true ] && echo -ne "\e[?1000;1006;1015l" && options[mouse]=false && return
	[ "${options[mouse]}" = false ] && echo -ne "\e[?1000;1006;1015h" && options[mouse]=true && return
}
menuclick() {
	#determine which item should be triggered
	[ -z $1 ] && menulinep=0 || menulinep=$1
	local cx=0
	for a in "${!menuline[@]}"; {
		la="${#a}"
		((menulinep>cx)) && ((menulinep<(cx + la + 1))) && ${menuline[$a]}
		cx=$(( cx + la + 1 ))
	}
}
menu() {
	local -i dc=0
	printf '\e[?25l'
	while true; do
		local -a k=()
		local -i i=1
		printf '\e[%s;0H' $menulinepy
		local mi=0
		for action in "${!menucon[@]}"; do
			if [ $mi = $dc ]; then
				printf "\e[%sC${style[menuitemselected]}%s\e[0;0m\n" $menulinep "$action"  
			else
				printf "\e[%sC${style[menuitem]}%s\e[0;0m\n" $menulinep "$action"
			fi
			((mi++))
		done
		local -a kb=()
        if read -rsN1 -t"${options[timeout]}" kb[0]; then # Check for ready input
			while read -rsN1 -t0.0001 kb[$i]; do ((i++)); done # Multibyte hack
			makehexkey "$(printf '%s' "${kb[@]}")"
			case "${hexkey[*]}" in
				"${keys_def[up]}") ((dc--)) ;;
				"${keys_def[down]}") ((dc++)) ;;
				"${keys_def[select]}")
					mi=0
					for action in "${!menucon[@]}"; do
						[ $mi = $dc ] && ${menucon[$action]}
						printf '%s\n' $mi $dc
						((mi++))
					done
					return
					;;
				*) redraw; return ;;
			esac
			(( "$dc" > ( "${#menucon[@]}" - 1))) && ((dc--))
			(( "$dc" < 0 )) && ((dc++))
		fi
	done
}
redraw() {
	printf "\e[0m\e[H${style[menuline]}\e[?25l%*s\r" "$COLUMNS"
	printf '%s\e[0m' "${!menuline[*]}"
	
    for ((i = base; i - base < LINES - reservedlines; i++)); do # Iterate over shown lines
		printf "${style[numberselected]}"
        ((i != line)) && printf "${style[number]}" # Fade line number if not selected
        ((i > ${#buffer[@]})) && printf "\n${style[numberempty]}\e[K   ~\e[m"\
				|| printf "\n\e[K%4s\e[m %s" "$i" "${buffersyntax[i]}"
	done
	
	printf "\n\e[?25l${style[infoline]}%*s\r %s (%s,%s)\e[m" \
			"$COLUMNS" "(C-g to open top menu) $message" \
			"$(basenam "$file") ($filetype)" "$line" "${rl}" # Status line, among others
    printf '\e[?25h\e[%s;%sH' $((line + 2 - base)) $(( rl + 6 )) # move cursor to the line
}

makehexkey() {
	hexkey=()
	local -i i=0
	echo "$1" | {
		while read -rsn1; do
			hexkey[i]="$(printf "%x\n" "'${1:$i}")"
			((i++))
		done
	}
}
keytype() {
	makehexkey "$1"

	#handle all keybindings for edit mode
	for str in "${!keys_edit[@]}"; do
		[ "$str" = "${hexkey[*]}" ] && "${keys_edit[$str]}" && return
	done

	#parse mouse stuff somewhatish weirdly
	[ "${hexkey[*]:0:5}" = '1b 5b 3c 36 34' ] && up && return
	[ "${hexkey[*]:0:5}" = '1b 5b 3c 36 35' ] && down && return
	[ "${hexkey[*]:0:5}" = '1b 5b 3c 38 30' ] && up 9 && return
	[ "${hexkey[*]:0:5}" = '1b 5b 3c 38 31' ] && down 9 && return
	[ "${hexkey[0]}" = '1b' ] && [ "${1: -1}" = 'm' ] && {
		value=0
		echo "$1" | while read -rsn1 mchar; do
			case "$mchar" in
				'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|9)tmp="${tmp}${mchar}";;
				'm'|'M'|';') {
					[ "$value" = '0' ] && mode="${tmp}" && tmp=
					[ "$value" = '1' ] && x="${tmp}" && tmp=
					[ "$value" = '2' ] && y="${tmp}" && tmp=
				};;
			esac
			case "$mchar" in
				';')((value++));;
				'm'|'M')value=0 && break;;
			esac
		done
		#limitations of movenment
		[ $y = 1 ] && menuclick $x && return #handle menuline
		[ $x -lt 6 ] && {
			if [ "$mode" = 0 ]; then
				line=$(( base + ( y - 2 ) ))
				redraw
			elif [ "$mode" = 2 ]; then #VERY BAD SOLUTION, TODO: FIX
				clr
				echo enter line number
				read -r line
				scrinit
				redraw
			fi
			return
		}
		line=$(( base + ( y - 2 ) ))
		rl=$(( x - 6 ))
		((line > ${#buffer[@]})) && line=${#buffer[@]}
		((rl > ${#buffer[line]})) && rl=${#buffer[line]}
		redraw
		return
	}
	[ "${hexkey[*]:0:3}" = '1b 5b 3c' ] && return
	local -i rlr
	unset ta
	local ta
	ta=${bufferexpand[line]:0:rl}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((rl + ta / 4 - ta))	
	buffer[line]="${buffer[line]:0:${rlr}}$1${buffer[line]:${rlr}}" #add at cursor position - amount of tabs * tab size
	#go right with cursor
	megaredrawline #not sure why this is needed but it prevents duplication of the letter
	right
	redraw
	[ "$1" = '	' ] && printf '\e[%sC' $((${#options[tabchar]} - 1))
	modified=true
}
main() {
	scrinit
    if [[ "$1" ]]; then # If a file was provided in the terminal pre-load it
        #redraw # Draw out the UI before loading file
        read_buffer "$1"
    else
		filepick # enter the file selector
	fi
    redraw
    while true; do
        local -a k=()
        local -i i=1    
        if read -rsN1 -t${options[refresh_timeout]} k[0]; then # Check for ready input
           while read -rsN1 -t0.0001 k[$i]; do ((i++)); done # Multibyte hack
            keytype "$(printf '%s' "${k[@]}")" # Handle keypress event
        fi
    done
}

redrawa() {
	redraw #i have no idea why it has to be twice to work
	redraw
}
shopt -s checkwinsize; (redraw) # Enable and then trigger a terminal size refresh
trap redrawa WINCH ALRM # Attach WINCH and ALRM to redraw the screen
trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
trap quit INT
trap quit SIGTERM

main "$@"
printf '\e[?7h'
